<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Zoomies</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            align-items: start;
            transition: grid-template-columns 0.3s ease;
        }

        .container.controls-hidden {
            grid-template-columns: 0 1fr;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            transform: translateX(-20px);
            pointer-events: none;
        }

        .header-logo {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 32px;
            padding-bottom: 24px;
            border-bottom: 2px solid #2a2a2a;
        }

        .logo-image {
            width: 72px;
            height: 72px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 3px solid rgba(74, 158, 255, 0.4);
            border-radius: 12px;
            background: #0a0a0a;
            padding: 8px;
            box-shadow: 0 0 20px rgba(74, 158, 255, 0.2);
        }

        h1 {
            font-size: 24px;
            color: #fff;
            margin: 0;
            text-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        .subtitle {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
            letter-spacing: 1px;
        }

        h2 {
            font-size: 16px;
            margin: 24px 0 0 0;
            color: #fff;
            padding: 12px;
            background: #0a0a0a;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2:hover {
            background: #151515;
        }

        h2::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.3s;
        }

        h2.collapsed::after {
            transform: rotate(-90deg);
        }

        .section-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        h3 {
            font-size: 14px;
            margin: 16px 0 8px 0;
            color: #4a9eff;
        }

        .control-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 2px dashed #444;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
        }

        input[type="text"],
        input[type="url"],
        input[type="number"],
        input[type="color"],
        select,
        textarea {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
        }

        textarea {
            min-height: 60px;
            resize: vertical;
            font-family: inherit;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            cursor: pointer;
        }

        .range-value {
            float: right;
            color: #888;
            font-size: 12px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        button:hover {
            background: #3a8eef;
        }

        button.secondary {
            background: #2a2a2a;
        }

        button.secondary:hover {
            background: #3a3a3a;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            color: #e0e0e0;
            transition: background 0.2s;
        }

        .toggle-controls:hover {
            background: #2a2a2a;
        }

        .preview-wrapper {
            background: #0a0a0a;
            border-radius: 12px;
            border: 1px solid #2a2a2a;
            height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
        }

        .zoom-container {
            height: 300vh;
            position: relative;
        }

        .sticky-stage {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .image-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 98%;
        }

        .image-container {
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        #zoomImage {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
            object-position: center;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
        }

        .text-overlay {
            position: absolute;
            padding: 12px 20px;
            border-radius: 4px;
            z-index: 10;
            max-width: 80%;
            opacity: 1;
        }

        .caption-overlay {
            position: relative;
            width: 85%;
            max-width: 700px;
            padding: 10px 16px;
            background: rgba(0,0,0,0.9);
            font-size: 13px;
            line-height: 1.5;
            opacity: 1;
            z-index: 20;
        }

        .caption-credit {
            color: #999;
            font-size: 11px;
            font-style: italic;
            margin-top: 4px;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .zoom-anchor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #4a9eff;
            border-radius: 50%;
            background: rgba(74, 158, 255, 0.3);
            transform: translate(-50%, -50%);
            z-index: 30;
            pointer-events: none;
        }

        .zoom-anchor.anchor-2 {
            border-color: #ff4a9e;
            background: rgba(255, 74, 158, 0.3);
        }

        .zoom-anchor::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #4a9eff;
            border-radius: 50%;
        }

        .zoom-anchor.anchor-2::after {
            background: #ff4a9e;
        }

        .anchor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 25;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .modal-close {
            background: #2a2a2a;
            border: none;
            color: #e0e0e0;
            font-size: 20px;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            margin: 0;
        }

        #exportCode {
            flex: 1;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 16px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
            margin-bottom: 16px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .help-text {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .anchor-section {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .divider {
            text-align: center;
            color: #666;
            margin: 12px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="toggle-controls" onclick="toggleControls()">‚ò∞ Controls</div>

    <div class="container" id="container">
        <div class="panel controls" id="controls">
            <div class="header-logo">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAEw0lEQVR4nO3dsWoUURjF8Y1MkyZtiu0DYRAhRfq0IuYF8hoi24ooYiNinyadiCBimz5FQGQIpN8XSIot9QXuCRzPd7Mb/f/KcZ3d7B4ue7gz327NcC/GcfxdcZ5pmtQ/bVWc3/VoHU+KfwcBQoQAIUKAECFAiBAgRAgQIgQIEQKECAFChAAh0n3/5OzszNoDOjo6ah7f3d1tHr+8vPRfVMN8Prcev1wuuz7vzs5O8/jV1VXz+OcvX63n/fH9W/P4NE1WJliBECFAiBAgRAgQIgQIEbuFLZfLZqtSrWF7e7t53G1PBwcH1uMfutVq1TyuWpj7/qjzv3r9pnn8/bu3zaywAiFCgBAhQIgQIEQIECKyhak9rOPj4+bjb25umsfVntH19XXzuNoLUy1PUe3PpdpK7+dVVHtV76f6vNx2fHh4SAtDPQKECAFChAAhQoAQGdz/oNqW4rYt93lVO+vdntz3wT2/ev3unpe7d6Y+L4UVCBEChAgBQoQAIUKAEBnc+7bc+5WqqD01ddy938ptbYpqZ26LVK1Nvc79/f3mcfdz+flLzmBsYgVChAAhQoAQIUCIECBEBvWtW90HdHFxYbW2vb096wW5Uy/U3o07bUNx97yUqhapqDbn7m2pqR2z2az5ubMCIUKAECFAiBAgRAgQIoNqW4r7rV61sA8fPzWPu69HtULVbty9J7eFuS1SzTZUbWixWDSPq/u/FPdzVFiBECFAiBAgRAgQIgQIEfu+sJOTk2ZLevFy0WxDqoXdsedSomovTE3Id69gVO3syePRfk0tqi2q919N21C/Lj2O7dfJCoQIAUKEACFCgBAhQIjYLUxx24Ta05mJK9/cKxuV3jMM3VmOStXfq6jWrKjWzAqECAFChAAhQoAQIUCIlLUwpeoKxqr7pKpmJ7ptrqr9Vf1atHvlp8IKhAgBQoQAIUKAECFAiJS1MHWloprB6M7ic1uYO5NQqZqdqFpY75mTqgWrKw+VaZr4vTDUI0CIECBECBAiBAiRkv2Qv6GuiFNXNrp7ZKrdVM08rJowXzX9Q7Ut1Y4V90pFViBECBAiBAgRAoQIAUJky/29MMX9tq+o1+O2sKoJ8O4VgL1b4fn5efN41fuvqHbGCoQIAUKEACFCgBAhQIiUXZHo7qFU3Zc0n8+tWX+KuuKu6jy3t7fWeVT76922FPV5sQIhQoAQIUCIECBECBAig9pjcqdquDMS3T2vqt+3Uty25Z5H3edVNVF/XViBECFAiBAgRAgQIgQIkaGq3bjTOVzuNA+1J1VFta2nz55b51FXKlbNQuyNFQgRAoQIAUKEACFCgBAp+9Vm9/GqnalW6O61qZZU1c6mqd0K1e+gqT2vqmkhVdSVpVyRiC4IECIECBEChAgBQmRtMxIVd+9M7ZHdcd+ZOr/1XqiWd3p62ny8e+XhuqZwuFiBECFAiBAgRAgQIgQIkY36Rn8Xd49Gqdojq5q0XzVhvjf1vrECIUKAECFAiBAgRAgQIhv1Tf8+VM08VKrug3Otq7WxAiFCgBAhQIgQIEQIECL/XQtTVHty72tTe15K79mPvdsZKxAiBAgRAoQIAUKEACEy9J5isWncvap17W09FKxAiBAgRAgQIgQIEQKEyB9J7KLqgGQZnAAAAABJRU5ErkJggg==" alt="Pixel Dog Logo" class="logo-image">
                <div>
                    <h1>Scrolltastic Zoomies</h1>
                    <div class="subtitle">SCROLL-BASED IMAGE ZOOM TOOL</div>
                </div>
            </div>

            <h2 onclick="toggleSection('imageSource')">Image Source</h2>
            <div class="section-content" id="imageSource">
                <div class="control-group">
                    <label>Upload Image File</label>
                    <input type="file" id="imageInput" accept="image/*">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                        <button onclick="loadExampleZoom()" style="background: #9b59b6;">Load Example</button>
                        <button onclick="clearZoom()" style="background: #e74c3c;">Clear All</button>
                    </div>
                </div>

                <div class="divider">‚Äî OR ‚Äî</div>

                <div class="control-group">
                    <label>Image URL</label>
                    <input type="url" id="imageUrl" placeholder="https://example.com/image.jpg">
                    <div class="help-text">Use direct link for easy updates</div>
                </div>

                <button class="secondary" onclick="loadImageFromUrl()">Load from URL</button>
            </div>

            <h2 onclick="toggleSection('zoomSettings')" class="collapsed">Zoom Settings</h2>
            <div class="section-content collapsed" id="zoomSettings">
                <div class="control-group">
                    <label>Image Fit</label>
                    <select id="imageFit">
                        <option value="cover" selected>Cover (fill viewport)</option>
                        <option value="contain">Contain (fit whole image)</option>
                        <option value="fill">Fill (stretch to fit)</option>
                        <option value="none">None (actual size)</option>
                    </select>
                    <div class="help-text">How the image fills the viewport</div>
                </div>

                <div class="control-group">
                    <label>Aspect Ratio</label>
                    <select id="aspectRatio">
                        <option value="auto">Auto (original)</option>
                        <option value="16:9">16:9 (Landscape)</option>
                        <option value="9:16">9:16 (Portrait/Mobile)</option>
                        <option value="4:3">4:3 (Classic)</option>
                        <option value="3:4">3:4 (Portrait)</option>
                        <option value="1:1">1:1 (Square)</option>
                        <option value="21:9">21:9 (Ultrawide)</option>
                        <option value="3:2">3:2 (Photography)</option>
                        <option value="2:3">2:3 (Portrait Photo)</option>
                    </select>
                    <div class="help-text">Force specific aspect ratio</div>
                </div>

                <div class="control-group">
                    <label>Zoom Direction</label>
                    <select id="zoomDirection">
                        <option value="in">Zoom In (Scale Up)</option>
                        <option value="out">Zoom Out (Scale Down)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Zoom Start <span class="range-value" id="zoomStartValue">1√ó</span></label>
                    <input type="range" id="zoomStart" min="0.5" max="3" step="0.1" value="1">
                </div>

                <div class="control-group">
                    <label>Zoom End <span class="range-value" id="zoomEndValue">1.3√ó</span></label>
                    <input type="range" id="zoomEnd" min="1" max="10" step="0.1" value="1.3">
                </div>

                <div class="control-group">
                    <label>Scroll Distance <span class="range-value" id="scrollDistValue">200vh</span></label>
                    <input type="range" id="scrollDistance" min="100" max="500" step="50" value="200">
                </div>
            </div>

            <h2 onclick="toggleSection('anchorPoints')" class="collapsed">Anchor Points</h2>
            <div class="section-content collapsed" id="anchorPoints">
                <div class="control-group">
                    <label>Anchor Mode</label>
                    <select id="anchorMode">
                        <option value="none">No Anchor (Center)</option>
                        <option value="single">Single Anchor Point</option>
                        <option value="dual">Dual Anchor Crossfade</option>
                    </select>
                </div>

                <div class="control-group" id="quickZoomSection" style="display: none;">
                    <label>
                        <input type="checkbox" id="quickZoom">
                        Quick Zoom Mode
                    </label>
                    <div class="help-text">Snappier transitions with easing curves</div>
                </div>

                <div class="anchor-section" id="anchor1Section">
                    <h3>Anchor Point 1 (Blue)</h3>
                    <div class="control-group">
                        <label>Anchor 1 X <span class="range-value" id="anchor1XValue">50%</span></label>
                        <input type="range" id="anchor1X" min="0" max="100" step="1" value="50">
                    </div>
                    <div class="control-group">
                        <label>Anchor 1 Y <span class="range-value" id="anchor1YValue">50%</span></label>
                        <input type="range" id="anchor1Y" min="0" max="100" step="1" value="50">
                    </div>
                    <button class="secondary" onclick="setAnchor(1)">Click Image to Set Point 1</button>
                </div>

                <div class="anchor-section" id="anchor2Section" style="display: none;">
                    <h3>Anchor Point 2 (Pink)</h3>
                    <div class="control-group">
                        <label>Anchor 2 X <span class="range-value" id="anchor2XValue">50%</span></label>
                        <input type="range" id="anchor2X" min="0" max="100" step="1" value="50">
                    </div>
                    <div class="control-group">
                        <label>Anchor 2 Y <span class="range-value" id="anchor2YValue">50%</span></label>
                        <input type="range" id="anchor2Y" min="0" max="100" step="1" value="50">
                    </div>
                    <button class="secondary" onclick="setAnchor(2)">Click Image to Set Point 2</button>
                </div>
            </div>

            <h2 onclick="toggleSection('textOverlay')" class="collapsed">Text Overlay</h2>
            <div class="section-content collapsed" id="textOverlay">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="textEnabled" checked>
                        Enable Text Overlay
                    </label>
                </div>

                <div class="control-group">
                    <label>Text Content</label>
                    <textarea id="textContent" placeholder="Enter your text..."></textarea>
                </div>

                <div class="control-group">
                    <label>Position</label>
                    <select id="textPosition">
                        <option value="top">Top</option>
                        <option value="center">Center</option>
                        <option value="bottom">Bottom</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Text Alignment</label>
                    <select id="textAlign">
                        <option value="left">Left</option>
                        <option value="center">Center</option>
                        <option value="right">Right</option>
                        <option value="justify">Justify</option>
                        <option value="justify-left">Justify (Left last line)</option>
                        <option value="justify-right">Justify (Right last line)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Font Size <span class="range-value" id="textSizeValue">32px</span></label>
                    <input type="range" id="textSize" min="12" max="96" step="1" value="32">
                </div>

                <div class="control-group">
                    <label>Text Color</label>
                    <input type="color" id="textColor" value="#ffffff">
                </div>

                <div class="control-group">
                    <label>Line Height <span class="range-value" id="lineHeightValue">1.4</span></label>
                    <input type="range" id="lineHeight" min="0.8" max="3" step="0.1" value="1.4">
                </div>

                <div class="control-group">
                    <label>Letter Spacing <span class="range-value" id="letterSpacingValue">0px</span></label>
                    <input type="range" id="letterSpacing" min="-5" max="20" step="0.5" value="0">
                </div>

                <div class="control-group">
                    <label>Font Weight <span class="range-value" id="fontWeightValue">400</span></label>
                    <input type="range" id="fontWeight" min="100" max="900" step="100" value="400">
                </div>

                <div class="control-group">
                    <label>Text Transform</label>
                    <select id="textTransform">
                        <option value="none">None</option>
                        <option value="uppercase">UPPERCASE</option>
                        <option value="lowercase">lowercase</option>
                        <option value="capitalize">Capitalize</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Max Width <span class="range-value" id="maxWidthValue">80%</span></label>
                    <input type="range" id="maxWidth" min="20" max="100" step="5" value="80">
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="textBgEnabled" checked>
                        Text Background
                    </label>
                </div>

                <div class="control-group">
                    <label>Background Opacity <span class="range-value" id="bgOpacityValue">80%</span></label>
                    <input type="range" id="bgOpacity" min="0" max="100" step="5" value="80">
                </div>

                <div class="control-group">
                    <label>Background Blur <span class="range-value" id="bgBlurValue">10px</span></label>
                    <input type="range" id="bgBlur" min="0" max="30" step="1" value="10">
                </div>

                <div class="control-group">
                    <label>Horizontal Offset <span class="range-value" id="textXValue">0px</span></label>
                    <input type="range" id="textX" min="-400" max="400" step="5" value="0">
                </div>

                <div class="control-group">
                    <label>Vertical Offset <span class="range-value" id="textYValue">0px</span></label>
                    <input type="range" id="textY" min="-400" max="400" step="5" value="0">
                </div>
            </div>

            <h2 onclick="toggleSection('caption')" class="collapsed">Caption</h2>
            <div class="section-content collapsed" id="caption">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="captionEnabled">
                        Enable Caption
                    </label>
                </div>

                <div class="control-group">
                    <label>Caption Text</label>
                    <textarea id="captionText" placeholder="Main caption...">this is a caption, use it as you would to caption photos and illustrations. Have a great time, don't hurt anyone.</textarea>
                </div>

                <div class="control-group">
                    <label>Credit/Source</label>
                    <input type="text" id="captionCredit" placeholder="Photo credit..." value="AP Photo Marshall Ritzel">
                </div>
            </div>

            <h2 onclick="toggleSection('export')" class="collapsed">Export</h2>
            <div class="section-content collapsed" id="export">
                <button onclick="exportHTML()">Export HTML</button>
                <button class="secondary" onclick="clearImage()">Clear Image</button>
            </div>
        </div>

        <div class="preview-wrapper" id="preview">
            <div class="empty-state">
                <div class="empty-state-icon">üñºÔ∏è</div>
                <div>Load an image to begin</div>
            </div>
        </div>
    </div>

    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Export HTML</h2>
                <button class="modal-close" onclick="closeModal()">√ó</button>
            </div>
            <textarea id="exportCode" readonly></textarea>
            <div class="grid-2">
                <button onclick="copyCode()">Copy to Clipboard</button>
                <button onclick="downloadHTML()">Download HTML</button>
            </div>
        </div>
    </div>

    <script>
        let currentImage = null;
        let currentImageUrl = null;
        let controlsVisible = true;
        let settingAnchor = 0;

        // Load example zoom image
        function loadExampleZoom() {
            const exampleURL = 'https://discophooey.github.io/my_personal_digital_team/examples/PLACE_HOLDER.png';
            currentImageUrl = exampleURL;
            currentImage = exampleURL;
            updatePreview();
            alert('‚úì Loaded example image');
        }

        // Clear zoom
        function clearZoom() {
            if (!currentImage) return;
            
            if (confirm('Clear image?')) {
                currentImage = null;
                currentImageUrl = null;
                document.getElementById('imageInput').value = '';
                updatePreview();
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const header = section.previousElementSibling;
            section.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }

        function toggleControls() {
            controlsVisible = !controlsVisible;
            const container = document.getElementById('container');
            const controls = document.getElementById('controls');
            
            if (controlsVisible) {
                container.classList.remove('controls-hidden');
                controls.classList.remove('hidden');
            } else {
                container.classList.add('controls-hidden');
                controls.classList.add('hidden');
            }
        }

        function setAnchor(num) {
            settingAnchor = num;
            updatePreview();
        }

        function loadImageFromUrl() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) {
                alert('Please enter an image URL');
                return;
            }
            currentImageUrl = url;
            currentImage = url;
            updatePreview();
        }

        const ranges = {
            zoomStart: { el: 'zoomStart', display: 'zoomStartValue', suffix: '√ó' },
            zoomEnd: { el: 'zoomEnd', display: 'zoomEndValue', suffix: '√ó' },
            scrollDistance: { el: 'scrollDistance', display: 'scrollDistValue', suffix: 'vh' },
            textSize: { el: 'textSize', display: 'textSizeValue', suffix: 'px' },
            lineHeight: { el: 'lineHeight', display: 'lineHeightValue', suffix: '' },
            letterSpacing: { el: 'letterSpacing', display: 'letterSpacingValue', suffix: 'px' },
            fontWeight: { el: 'fontWeight', display: 'fontWeightValue', suffix: '' },
            maxWidth: { el: 'maxWidth', display: 'maxWidthValue', suffix: '%' },
            bgOpacity: { el: 'bgOpacity', display: 'bgOpacityValue', suffix: '%' },
            bgBlur: { el: 'bgBlur', display: 'bgBlurValue', suffix: 'px' },
            textX: { el: 'textX', display: 'textXValue', suffix: 'px' },
            textY: { el: 'textY', display: 'textYValue', suffix: 'px' },
            anchor1X: { el: 'anchor1X', display: 'anchor1XValue', suffix: '%' },
            anchor1Y: { el: 'anchor1Y', display: 'anchor1YValue', suffix: '%' },
            anchor2X: { el: 'anchor2X', display: 'anchor2XValue', suffix: '%' },
            anchor2Y: { el: 'anchor2Y', display: 'anchor2YValue', suffix: '%' }
        };

        Object.keys(ranges).forEach(key => {
            const range = ranges[key];
            const input = document.getElementById(range.el);
            const display = document.getElementById(range.display);
            input.addEventListener('input', () => {
                display.textContent = input.value + range.suffix;
                updatePreview();
            });
        });

        document.getElementById('anchorMode').addEventListener('change', function() {
            const mode = this.value;
            const anchor2Section = document.getElementById('anchor2Section');
            const quickZoomSection = document.getElementById('quickZoomSection');
            
            if (mode === 'dual') {
                anchor2Section.style.display = 'block';
                quickZoomSection.style.display = 'block';
            } else {
                anchor2Section.style.display = 'none';
                quickZoomSection.style.display = 'none';
            }
            updatePreview();
        });

        document.getElementById('quickZoom').addEventListener('change', updatePreview);
        document.getElementById('zoomDirection').addEventListener('change', updatePreview);
        document.getElementById('imageFit').addEventListener('change', updatePreview);
        document.getElementById('aspectRatio').addEventListener('change', updatePreview);

        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    currentImage = event.target.result;
                    currentImageUrl = null;
                    document.getElementById('imageUrl').value = '';
                    updatePreview();
                };
                reader.readAsDataURL(file);
            }
        });

        ['textEnabled', 'textContent', 'textPosition', 'textAlign', 'textColor', 'textTransform',
         'textBgEnabled', 'captionEnabled', 'captionText', 'captionCredit'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('change', updatePreview);
            el.addEventListener('input', updatePreview);
        });

        function updatePreview() {
            const preview = document.getElementById('preview');
            
            if (!currentImage) {
                preview.innerHTML = `<div class="empty-state"><div class="empty-state-icon">üñºÔ∏è</div><div>Load an image to begin</div></div>`;
                return;
            }

            const anchorMode = document.getElementById('anchorMode').value;
            const quickZoom = document.getElementById('quickZoom').checked;
            const zoomDirection = document.getElementById('zoomDirection').value;
            const imageFit = document.getElementById('imageFit').value;
            const aspectRatio = document.getElementById('aspectRatio').value;
            let zoomStart = parseFloat(document.getElementById('zoomStart').value);
            let zoomEnd = parseFloat(document.getElementById('zoomEnd').value);
            
            if (zoomDirection === 'out') [zoomStart, zoomEnd] = [zoomEnd, zoomStart];
            
            const scrollDist = parseInt(document.getElementById('scrollDistance').value);
            const anchor1X = parseFloat(document.getElementById('anchor1X').value);
            const anchor1Y = parseFloat(document.getElementById('anchor1Y').value);
            const anchor2X = parseFloat(document.getElementById('anchor2X').value);
            const anchor2Y = parseFloat(document.getElementById('anchor2Y').value);
            
            const textEnabled = document.getElementById('textEnabled').checked;
            const textContent = document.getElementById('textContent').value;
            const textPosition = document.getElementById('textPosition').value;
            const textAlign = document.getElementById('textAlign').value;
            const textSize = document.getElementById('textSize').value;
            const textColor = document.getElementById('textColor').value;
            const lineHeight = document.getElementById('lineHeight').value;
            const letterSpacing = document.getElementById('letterSpacing').value;
            const fontWeight = document.getElementById('fontWeight').value;
            const textTransform = document.getElementById('textTransform').value;
            const maxWidth = document.getElementById('maxWidth').value;
            const textBgEnabled = document.getElementById('textBgEnabled').checked;
            const bgOpacity = document.getElementById('bgOpacity').value / 100;
            const bgBlur = document.getElementById('bgBlur').value;
            const textX = document.getElementById('textX').value;
            const textY = document.getElementById('textY').value;
            
            const captionEnabled = document.getElementById('captionEnabled').checked;
            const captionText = document.getElementById('captionText').value;
            const captionCredit = document.getElementById('captionCredit').value;

            let posStyle = '';
            if (textPosition === 'top') posStyle = 'top: 20px;';
            else if (textPosition === 'center') posStyle = 'top: 50%; transform: translate(-50%, -50%);';
            else posStyle = 'bottom: 20px;';

            const bgStyle = textBgEnabled ? `background: rgba(0,0,0,${bgOpacity}); backdrop-filter: blur(${bgBlur}px);` : '';

            let actualTextAlign = textAlign;
            let textAlignLast = '';
            if (textAlign === 'justify-left') {
                actualTextAlign = 'justify';
                textAlignLast = 'text-align-last: left;';
            } else if (textAlign === 'justify-right') {
                actualTextAlign = 'justify';
                textAlignLast = 'text-align-last: right;';
            }

            let textOverlay = '';
            if (textEnabled && textContent) {
                textOverlay = `<div class="text-overlay" style="${posStyle} left: 50%; transform: translateX(-50%); margin-left: ${textX}px; margin-top: ${textY}px; font-size: ${textSize}px; color: ${textColor}; text-align: ${actualTextAlign}; ${textAlignLast} line-height: ${lineHeight}; letter-spacing: ${letterSpacing}px; font-weight: ${fontWeight}; text-transform: ${textTransform}; max-width: ${maxWidth}%; ${bgStyle}">${textContent.replace(/\n/g, '<br>')}</div>`;
            }

            let captionOverlay = '';
            if (captionEnabled && (captionText || captionCredit)) {
                captionOverlay = `<div class="caption-overlay">${captionText ? captionText : ''}${captionCredit ? `<div class="caption-credit">${captionCredit}</div>` : ''}</div>`;
            }

            let anchorPoints = '';
            let anchorOverlay = '';
            
            if (anchorMode === 'single') {
                anchorPoints = `<div class="zoom-anchor" style="left: ${anchor1X}%; top: ${anchor1Y}%;"></div>`;
                if (settingAnchor === 1) anchorOverlay = `<div class="anchor-overlay" id="anchorOverlay"></div>`;
            } else if (anchorMode === 'dual') {
                anchorPoints = `<div class="zoom-anchor" style="left: ${anchor1X}%; top: ${anchor1Y}%;"></div><div class="zoom-anchor anchor-2" style="left: ${anchor2X}%; top: ${anchor2Y}%;"></div>`;
                if (settingAnchor > 0) anchorOverlay = `<div class="anchor-overlay" id="anchorOverlay"></div>`;
            }

            // Calculate aspect ratio styling
            let aspectRatioStyle = '';
            if (aspectRatio !== 'auto') {
                const [width, height] = aspectRatio.split(':').map(Number);
                const ratio = (height / width) * 100;
                aspectRatioStyle = `aspect-ratio: ${width} / ${height}; height: auto;`;
            } else {
                aspectRatioStyle = 'height: 100%;';
            }

            preview.innerHTML = `<div class="zoom-container" style="height: ${scrollDist}vh;"><div class="sticky-stage"><div class="image-wrapper"><div class="image-container" style="${aspectRatioStyle}"><img id="zoomImage" src="${currentImage}" style="object-fit: ${imageFit};">${anchorPoints}${anchorOverlay}</div>${textOverlay}${captionOverlay}</div></div></div>`;

            const zoomImage = document.getElementById('zoomImage');
            
            preview.addEventListener('scroll', () => {
                const scrollTop = preview.scrollTop;
                const maxScroll = preview.scrollHeight - preview.clientHeight;
                let progress = Math.min(scrollTop / maxScroll, 1);
                
                if (anchorMode === 'dual' && quickZoom) progress = easeInOutCubic(progress);
                
                const currentZoom = zoomStart + (zoomEnd - zoomStart) * progress;
                
                if (anchorMode === 'none') {
                    zoomImage.style.transformOrigin = '50% 50%';
                } else if (anchorMode === 'single') {
                    zoomImage.style.transformOrigin = `${anchor1X}% ${anchor1Y}%`;
                } else if (anchorMode === 'dual') {
                    const currentX = anchor1X + (anchor2X - anchor1X) * progress;
                    const currentY = anchor1Y + (anchor2Y - anchor1Y) * progress;
                    zoomImage.style.transformOrigin = `${currentX}% ${currentY}%`;
                }
                
                zoomImage.style.transform = `scale(${currentZoom})`;
            });

            if (settingAnchor > 0) {
                const anchorOverlayEl = document.getElementById('anchorOverlay');
                if (anchorOverlayEl) {
                    anchorOverlayEl.style.pointerEvents = 'auto';
                    anchorOverlayEl.addEventListener('click', function(e) {
                        const rect = zoomImage.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        
                        if (settingAnchor === 1) {
                            document.getElementById('anchor1X').value = Math.round(x);
                            document.getElementById('anchor1Y').value = Math.round(y);
                            document.getElementById('anchor1XValue').textContent = Math.round(x) + '%';
                            document.getElementById('anchor1YValue').textContent = Math.round(y) + '%';
                        } else if (settingAnchor === 2) {
                            document.getElementById('anchor2X').value = Math.round(x);
                            document.getElementById('anchor2Y').value = Math.round(y);
                            document.getElementById('anchor2XValue').textContent = Math.round(x) + '%';
                            document.getElementById('anchor2YValue').textContent = Math.round(y) + '%';
                        }
                        
                        settingAnchor = 0;
                        updatePreview();
                    });
                }
            }
        }

        function clearImage() {
            if (confirm('Clear the current image?')) {
                currentImage = null;
                currentImageUrl = null;
                document.getElementById('imageInput').value = '';
                document.getElementById('imageUrl').value = '';
                updatePreview();
            }
        }

        function exportHTML() {
            if (!currentImage) {
                alert('Please load an image first!');
                return;
            }

            const anchorMode = document.getElementById('anchorMode').value;
            const quickZoom = document.getElementById('quickZoom').checked;
            const zoomDirection = document.getElementById('zoomDirection').value;
            const imageFit = document.getElementById('imageFit').value;
            const aspectRatio = document.getElementById('aspectRatio').value;
            let zoomStart = document.getElementById('zoomStart').value;
            let zoomEnd = document.getElementById('zoomEnd').value;
            
            if (zoomDirection === 'out') [zoomStart, zoomEnd] = [zoomEnd, zoomStart];
            
            const scrollDist = document.getElementById('scrollDistance').value;
            const anchor1X = document.getElementById('anchor1X').value;
            const anchor1Y = document.getElementById('anchor1Y').value;
            const anchor2X = document.getElementById('anchor2X').value;
            const anchor2Y = document.getElementById('anchor2Y').value;
            
            const textEnabled = document.getElementById('textEnabled').checked;
            const textContent = document.getElementById('textContent').value;
            const textPosition = document.getElementById('textPosition').value;
            const textAlign = document.getElementById('textAlign').value;
            const textSize = document.getElementById('textSize').value;
            const textColor = document.getElementById('textColor').value;
            const lineHeight = document.getElementById('lineHeight').value;
            const letterSpacing = document.getElementById('letterSpacing').value;
            const fontWeight = document.getElementById('fontWeight').value;
            const textTransform = document.getElementById('textTransform').value;
            const maxWidth = document.getElementById('maxWidth').value;
            const textBgEnabled = document.getElementById('textBgEnabled').checked;
            const bgOpacity = document.getElementById('bgOpacity').value / 100;
            const bgBlur = document.getElementById('bgBlur').value;
            const textX = document.getElementById('textX').value;
            const textY = document.getElementById('textY').value;
            
            const captionEnabled = document.getElementById('captionEnabled').checked;
            const captionText = document.getElementById('captionText').value;
            const captionCredit = document.getElementById('captionCredit').value;

            const imageSource = currentImageUrl || currentImage;

            let posStyle = '';
            if (textPosition === 'top') posStyle = 'top: 20px;';
            else if (textPosition === 'center') posStyle = 'top: 50%; transform: translate(-50%, -50%);';
            else posStyle = 'bottom: 20px;';

            const bgStyle = textBgEnabled ? `background: rgba(0,0,0,${bgOpacity}); backdrop-filter: blur(${bgBlur}px);` : '';

            let actualTextAlign = textAlign;
            let textAlignLast = '';
            if (textAlign === 'justify-left') {
                actualTextAlign = 'justify';
                textAlignLast = 'text-align-last: left;';
            } else if (textAlign === 'justify-right') {
                actualTextAlign = 'justify';
                textAlignLast = 'text-align-last: right;';
            }

            let textOverlay = '';
            if (textEnabled && textContent) {
                textOverlay = `<div class="text-overlay" style="${posStyle} left: 50%; transform: translateX(-50%); margin-left: ${textX}px; margin-top: ${textY}px; font-size: ${textSize}px; color: ${textColor}; text-align: ${actualTextAlign}; ${textAlignLast} line-height: ${lineHeight}; letter-spacing: ${letterSpacing}px; font-weight: ${fontWeight}; text-transform: ${textTransform}; max-width: ${maxWidth}%; ${bgStyle}">${textContent.replace(/\n/g, '<br>')}</div>`;
            }

            let captionOverlay = '';
            if (captionEnabled && (captionText || captionCredit)) {
                captionOverlay = `<div class="caption-overlay">${captionText ? captionText : ''}${captionCredit ? `<div class="caption-credit">${captionCredit}</div>` : ''}</div>`;
            }

            let easingFunction = '';
            if (anchorMode === 'dual' && quickZoom) {
                easingFunction = `
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }`;
            }

            let zoomScript = '';
            if (anchorMode === 'none') {
                zoomScript = `
        function updateZoom() {
            const scrollTop = window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const progress = Math.min(scrollTop / maxScroll, 1);
            const currentZoom = zoomStart + (zoomEnd - zoomStart) * progress;
            zoomImage.style.transformOrigin = '50% 50%';
            zoomImage.style.transform = 'scale(' + currentZoom + ')';
        }`;
            } else if (anchorMode === 'single') {
                zoomScript = `
        function updateZoom() {
            const scrollTop = window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const progress = Math.min(scrollTop / maxScroll, 1);
            const currentZoom = zoomStart + (zoomEnd - zoomStart) * progress;
            zoomImage.style.transformOrigin = '${anchor1X}% ${anchor1Y}%';
            zoomImage.style.transform = 'scale(' + currentZoom + ')';
        }`;
            } else {
                const progressCalc = quickZoom ? 'easeInOutCubic(progress)' : 'progress';
                zoomScript = `
        function updateZoom() {
            const scrollTop = window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            let progress = Math.min(scrollTop / maxScroll, 1);
            ${quickZoom ? 'progress = ' + progressCalc + ';' : ''}
            const currentZoom = zoomStart + (zoomEnd - zoomStart) * progress;
            const currentX = ${anchor1X} + (${anchor2X} - ${anchor1X}) * progress;
            const currentY = ${anchor1Y} + (${anchor2Y} - ${anchor1Y}) * progress;
            zoomImage.style.transformOrigin = currentX + '% ' + currentY + '%';
            zoomImage.style.transform = 'scale(' + currentZoom + ')';
        }`;
            }

            // Calculate aspect ratio styling for export
            let aspectRatioStyleExport = '';
            let imageContainerStyle = '';
            if (aspectRatio !== 'auto') {
                const [width, height] = aspectRatio.split(':').map(Number);
                imageContainerStyle = `aspect-ratio: ${width} / ${height}; height: auto;`;
            } else {
                imageContainerStyle = 'height: 100%;';
            }

            const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Zoomies</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; overflow-x: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        
        .zoom-container { height: ${scrollDist}vh; position: relative; }
        .sticky-stage { position: sticky; top: 0; width: 100%; height: 100vh; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .image-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; width: 98%; }
        .image-container { position: relative; width: 100%; overflow: hidden; ${imageContainerStyle} }
        #zoomImage { width: 100%; height: 100%; display: block; object-fit: ${imageFit}; object-position: center; transition: transform 0.1s ease-out; }
        .text-overlay { position: absolute; padding: 12px 20px; border-radius: 4px; z-index: 10; opacity: 1; }
        .caption-overlay { position: relative; width: 85%; max-width: 700px; padding: 10px 16px; background: rgba(0,0,0,0.9); font-size: 13px; line-height: 1.5; opacity: 1; z-index: 20; }
        .caption-credit { color: #999; font-size: 11px; font-style: italic; margin-top: 4px; }
    </style>
</head>
<body>
    <div class="zoom-container">
        <div class="sticky-stage">
            <div class="image-wrapper">
                <div class="image-container">
                    <img id="zoomImage" src="${imageSource}">
                </div>
                ${textOverlay}
                ${captionOverlay}
            </div>
        </div>
    </div>
    <scr` + `ipt>
        const zoomImage = document.getElementById('zoomImage');
        const zoomStart = ${zoomStart};
        const zoomEnd = ${zoomEnd};
        ${easingFunction}${zoomScript}
        
        window.addEventListener('scroll', updateZoom);
        updateZoom();
    </scr` + `ipt>
</body>
</html>`;

            document.getElementById('exportCode').value = html;
            document.getElementById('exportModal').classList.add('active');
        }

        function copyCode() {
            const code = document.getElementById('exportCode');
            code.select();
            document.execCommand('copy');
            alert('Code copied to clipboard!');
        }

        function downloadHTML() {
            const code = document.getElementById('exportCode').value;
            const blob = new Blob([code], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'scrolltastic-zoomies.html';
            a.click();
            URL.revokeObjectURL(url);
        }

        function closeModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        updatePreview();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantastic Scrolltastic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            align-items: start;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
            color: #fff;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #fff;
            border-bottom: 1px solid #2a2a2a;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 2px dashed #444;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
        }

        input[type="file"]:hover {
            border-color: #666;
            background: #333;
        }

        input[type="number"],
        input[type="range"],
        select {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #888;
            font-size: 13px;
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            transform: scale(0.98);
        }

        .preview-container {
            position: relative;
        }

        .preview-wrapper {
            background: #0a0a0a;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #2a2a2a;
            height: 600px;
            overflow-y: scroll;
        }

        .preview-scroll-content {
            position: relative;
        }

        #previewCanvas {
            display: block;
            margin: 0 auto;
            position: sticky;
            top: 0;
        }

        .scroll-indicator {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 14px;
        }

        .file-info {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        .preset-info {
            display: inline-block;
            margin-left: 10px;
            font-size: 11px;
            color: #888;
            font-style: italic;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            color: #4a9eff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .copy-btn {
            margin-top: 10px;
            background: #2a2a2a;
        }

        .copy-btn:hover {
            background: #3a3a3a;
        }

        .code-section {
            margin-top: 20px;
        }

        .text-overlay-item {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .text-overlay-item h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #4a9eff;
        }

        .remove-text-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4444;
            padding: 5px 10px;
            font-size: 12px;
            width: auto;
        }

        .remove-text-btn:hover {
            background: #cc0000;
        }

        textarea.text-input {
            min-height: 60px;
            resize: vertical;
        }

        .frame-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                position: relative;
                top: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel controls">
            <h1>Fantastic Scrolltastic</h1>
            
            <div class="control-group">
                <label>Load Images</label>
                <select id="loadMethod" onchange="toggleLoadMethod()">
                    <option value="upload">Upload from Local</option>
                    <option value="url">Load from URL Folder</option>
                </select>
            </div>

            <div class="control-group" id="uploadSection">
                <label>Upload Image Sequence</label>
                <input type="file" id="imageInput" multiple accept="image/*">
                <div class="file-info" id="fileInfo">No files selected</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button onclick="loadExampleSequence()" style="background: #9b59b6;">Load Example</button>
                    <button onclick="clearAllFrames()" style="background: #e74c3c;">Clear All</button>
                </div>
            </div>

            <div class="control-group" id="urlSection" style="display: none;">
                <label>Image Folder URL Pattern</label>
                <input type="text" id="urlPattern" placeholder="https://example.com/images/frame{001-050}.jpg">
                <div class="file-info">Use {start-end} for number range (e.g., {001-030})</div>
                <button onclick="loadFromURL()" style="margin-top: 10px;">Load Images</button>
            </div>

            <div class="control-group">
                <label>Aspect Ratio Presets</label>
                <select id="aspectRatio" onchange="applyAspectRatio()">
                    <option value="custom">Custom</option>
                    <option value="9:16">Vertical Phone (9:16)</option>
                    <option value="16:9">Widescreen Phone (16:9)</option>
                    <option value="4:3">Desktop Standard (4:3)</option>
                    <option value="16:10">Desktop Wide (16:10)</option>
                    <option value="21:9">Ultrawide (21:9)</option>
                    <option value="1:1">Square (1:1)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Dimensions</label>
                <div class="dimension-inputs">
                    <div>
                        <input type="number" id="widthInput" placeholder="Width" value="800">
                    </div>
                    <div>
                        <input type="number" id="heightInput" placeholder="Height" value="600">
                    </div>
                </div>
                <div class="file-info" id="dimensionsInfo">800 x 600 (4:3 ratio)</div>
            </div>

            <div class="control-group">
                <label>Object Fit</label>
                <select id="objectFit">
                    <option value="contain">Contain</option>
                    <option value="cover">Cover</option>
                    <option value="fill">Fill</option>
                    <option value="none">None</option>
                </select>
            </div>

            <div class="control-group">
                <label>Scroll Speed <span class="range-value" id="speedValue">1.0x</span></label>
                <input type="range" id="scrollSpeed" min="0.1" max="3" step="0.1" value="1">
            </div>

            <div class="code-section">
                <h2>Custom Fonts</h2>
                <div class="control-group">
                    <label>Google Fonts URL or Font Name</label>
                    <input type="text" id="customFontInput" placeholder="e.g., Playfair Display or https://fonts.googleapis.com/css2?family=...">
                    <button onclick="addCustomFont()" style="margin-top: 10px;">Add Font</button>
                </div>
                <div id="customFontsList" class="file-info"></div>
            </div>

            <button onclick="updatePreview()">Update Preview</button>

            <div class="code-section">
                <h2>Text Overlays</h2>
                <button onclick="addTextOverlay()" style="background: #34a853; margin-bottom: 15px;">+ Add Text</button>
                <div id="textOverlaysList"></div>
            </div>

            <div class="code-section">
                <h2>Embed Code</h2>
                <textarea id="embedCode" readonly></textarea>
                <button class="copy-btn" onclick="copyCode()">Copy to Clipboard</button>
                <button class="copy-btn" onclick="downloadInstructions()" style="background: #34a853; margin-top: 10px;">Download Instructions (.txt)</button>
            </div>
        </div>

        <div class="panel preview-container">
            <h2>Preview</h2>
            <div class="preview-wrapper" id="previewWrapper">
                <div class="preview-scroll-content" id="scrollContent">
                    <canvas id="previewCanvas"></canvas>
                    <div class="scroll-indicator">
                        Upload images to preview scroll animation
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let images = [];
        let loadedImages = [];
        let textOverlays = [];
        let overlayIdCounter = 0;
        let customFonts = [];
        let currentConfig = {
            width: 800,
            height: 600,
            objectFit: 'contain',
            scrollSpeed: 1.0
        };

        const aspectRatioPresets = {
            '9:16': { width: 1080, height: 1920, name: 'Vertical Phone' },     // Instagram/TikTok vertical
            '16:9': { width: 1920, height: 1080, name: 'Widescreen Phone' },   // Landscape video
            '4:3': { width: 1024, height: 768, name: 'Desktop Standard' },     // Traditional desktop
            '16:10': { width: 1920, height: 1200, name: 'Desktop Wide' },      // MacBook ratio
            '21:9': { width: 2560, height: 1080, name: 'Ultrawide' },          // Ultrawide monitor
            '1:1': { width: 1080, height: 1080, name: 'Square' }               // Instagram square
        };

        // Load example sequence from GitHub
        async function loadExampleSequence() {
            const baseURL = 'https://discophooey.github.io/my_personal_digital_team/examples/examples/sequence/';
            const totalFrames = 20;
            
            images = [];
            loadedImages = [];
            
            document.getElementById('fileInfo').textContent = 'Loading example frames...';
            
            try {
                for (let i = 1; i <= totalFrames; i++) {
                    const frameNum = String(i).padStart(2, '0');
                    const url = `${baseURL}frame-${frameNum}.png`;
                    
                    console.log('Attempting to load:', url); // Debug log
                    
                    const img = new Image();
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            console.log('‚úì Loaded:', url); // Debug log
                            images.push({ src: url, file: { name: `frame-${frameNum}.png` } });
                            loadedImages.push(img);
                            document.getElementById('fileInfo').textContent = `Loading ${i}/${totalFrames} frames...`;
                            resolve();
                        };
                        img.onerror = (error) => {
                            console.error('‚úó Failed to load:', url, error); // Debug log
                            reject(new Error(`Failed to load frame ${i} from ${url}`));
                        };
                        img.src = url;
                    });
                }
                
                // Set 16:9 dimensions for example
                document.getElementById('widthInput').value = 1920;
                document.getElementById('heightInput').value = 1080;
                document.getElementById('aspectRatio').value = '16:9';
                checkCustomAspectRatio();
                
                document.getElementById('fileInfo').textContent = `‚úì Loaded ${totalFrames} example frames`;
                updatePreview();
                
            } catch (error) {
                console.error('Full error:', error); // Debug log
                document.getElementById('fileInfo').textContent = '‚úó ' + error.message;
                alert('Failed to load examples. Check console (F12) for details.\n\nTried URL: ' + baseURL + 'frame-01.png\n\nPlease verify:\n1. Files uploaded to GitHub\n2. GitHub Pages rebuilt (wait 2 min)\n3. Try visiting the URL directly in browser');
            }
        }

        // Clear all frames
        function clearAllFrames() {
            if (images.length === 0 && textOverlays.length === 0) {
                return;
            }
            
            if (confirm('Clear all frames and text overlays?')) {
                images = [];
                loadedImages = [];
                textOverlays = [];
                document.getElementById('fileInfo').textContent = 'No files selected';
                document.getElementById('imageInput').value = '';
                updatePreview();
                renderTextOverlays();
            }
        }

        function applyAspectRatio() {
            const selected = document.getElementById('aspectRatio').value;
            
            if (selected === 'custom') {
                return;
            }
            
            const preset = aspectRatioPresets[selected];
            if (preset) {
                document.getElementById('widthInput').value = preset.width;
                document.getElementById('heightInput').value = preset.height;
            }
        }

        // Update aspect ratio dropdown when dimensions change manually
        document.getElementById('widthInput').addEventListener('input', checkCustomAspectRatio);
        document.getElementById('heightInput').addEventListener('input', checkCustomAspectRatio);

        function checkCustomAspectRatio() {
            const width = parseInt(document.getElementById('widthInput').value);
            const height = parseInt(document.getElementById('heightInput').value);
            
            if (!width || !height) {
                document.getElementById('dimensionsInfo').textContent = 'Enter dimensions';
                return;
            }
            
            // Calculate GCD for ratio display
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(width, height);
            const ratioW = width / divisor;
            const ratioH = height / divisor;
            
            // Check if current dimensions match a preset
            let matchesPreset = false;
            let presetName = '';
            for (const [ratio, preset] of Object.entries(aspectRatioPresets)) {
                if (preset.width === width && preset.height === height) {
                    document.getElementById('aspectRatio').value = ratio;
                    matchesPreset = true;
                    presetName = preset.name;
                    break;
                }
            }
            
            if (matchesPreset) {
                document.getElementById('dimensionsInfo').textContent = 
                    `${width} x ${height} (${ratioW}:${ratioH} - ${presetName})`;
            } else {
                document.getElementById('aspectRatio').value = 'custom';
                document.getElementById('dimensionsInfo').textContent = 
                    `${width} x ${height} (${ratioW}:${ratioH} ratio)`;
            }
        }

        function addCustomFont() {
            const input = document.getElementById('customFontInput');
            const value = input.value.trim();
            
            if (!value) {
                alert('Please enter a font name or Google Fonts URL');
                return;
            }
            
            let fontName, fontUrl;
            
            // Check if it's a URL
            if (value.startsWith('http://') || value.startsWith('https://')) {
                fontUrl = value;
                // Try to extract font name from Google Fonts URL
                const match = value.match(/family=([^:&]+)/);
                if (match) {
                    fontName = decodeURIComponent(match[1]).replace(/\+/g, ' ');
                } else {
                    fontName = prompt('Enter the font family name (e.g., "Playfair Display"):');
                    if (!fontName) return;
                }
            } else {
                // It's a font name - construct Google Fonts URL
                fontName = value;
                const urlSafeName = fontName.replace(/\s+/g, '+');
                fontUrl = `https://fonts.googleapis.com/css2?family=${urlSafeName}:wght@400;700&display=swap`;
            }
            
            // Check if font already exists
            if (customFonts.some(f => f.name === fontName)) {
                alert('This font is already added');
                return;
            }
            
            // Add font link to document
            const link = document.createElement('link');
            link.href = fontUrl;
            link.rel = 'stylesheet';
            document.head.appendChild(link);
            
            // Add to custom fonts array
            customFonts.push({ name: fontName, url: fontUrl });
            
            // Clear input and update display
            input.value = '';
            updateCustomFontsList();
            
            // Update text overlay controls to include new font
            if (textOverlays.length > 0) {
                renderTextOverlaysList();
            }
        }
        
        function removeCustomFont(fontName) {
            customFonts = customFonts.filter(f => f.name !== fontName);
            updateCustomFontsList();
            renderTextOverlaysList();
        }
        
        function updateCustomFontsList() {
            const container = document.getElementById('customFontsList');
            if (customFonts.length === 0) {
                container.innerHTML = 'No custom fonts loaded';
                return;
            }
            
            container.innerHTML = customFonts.map(font => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #2a2a2a;">
                    <span style="font-family: '${font.name}'; font-size: 14px;">${font.name}</span>
                    <button onclick="removeCustomFont('${font.name.replace(/'/g, "\\'")}')" 
                            style="background: #ff4444; padding: 3px 8px; font-size: 11px; width: auto;">Remove</button>
                </div>
            `).join('');
        }

        function addTextOverlay() {
            const id = overlayIdCounter++;
            textOverlays.push({
                id: id,
                text: 'Your text here',
                startFrame: 0,
                endFrame: Math.max(10, loadedImages.length - 1),
                fadeInFrames: 5,
                fadeOutFrames: 5,
                fontSize: 24,
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center',
                verticalAlign: 'middle',
                textTransform: 'none',
                letterSpacing: 0,
                lineHeight: 1.2,
                xOffset: 0,
                yOffset: 0,
                shadowBlur: 0,
                shadowColor: '#000000'
            });
            renderTextOverlaysList();
            updatePreview();
        }

        function duplicateTextOverlay(id) {
            const original = textOverlays.find(t => t.id === id);
            if (original) {
                const newId = overlayIdCounter++;
                const duplicate = {
                    ...original,
                    id: newId,
                    text: original.text + ' (copy)'
                };
                textOverlays.push(duplicate);
                renderTextOverlaysList();
                updatePreview();
            }
        }

        function removeTextOverlay(id) {
            textOverlays = textOverlays.filter(t => t.id !== id);
            renderTextOverlaysList();
            updatePreview();
        }

        function updateTextOverlay(id, field, value) {
            const overlay = textOverlays.find(t => t.id === id);
            if (overlay) {
                if (field === 'fontSize' || field === 'startFrame' || field === 'endFrame' || 
                    field === 'fadeInFrames' || field === 'fadeOutFrames' || field === 'letterSpacing' || 
                    field === 'lineHeight' || field === 'shadowBlur' || 
                    field === 'xOffset' || field === 'yOffset') {
                    overlay[field] = parseFloat(value) || 0;
                } else {
                    overlay[field] = value;
                }
                updatePreview();
            }
        }

        function renderTextOverlaysList() {
            const container = document.getElementById('textOverlaysList');
            const maxFrames = Math.max(1, loadedImages.length - 1);
            
            container.innerHTML = textOverlays.map(overlay => `
                <div class="text-overlay-item">
                    <h3>Text Overlay ${overlay.id + 1}</h3>
                    <button class="remove-text-btn" onclick="removeTextOverlay(${overlay.id})">Remove</button>
                    <button class="remove-text-btn" onclick="duplicateTextOverlay(${overlay.id})" 
                            style="right: 90px; background: #34a853;">Duplicate</button>
                    
                    <div class="control-group">
                        <label>Text Content</label>
                        <textarea class="text-input" oninput="updateTextOverlay(${overlay.id}, 'text', this.value)">${overlay.text}</textarea>
                    </div>

                    <div class="control-group">
                        <label>Frame Range (0-${maxFrames})</label>
                        <div class="frame-range">
                            <input type="number" min="0" max="${maxFrames}" value="${overlay.startFrame}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'startFrame', this.value)" placeholder="Start">
                            <input type="number" min="0" max="${maxFrames}" value="${overlay.endFrame}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'endFrame', this.value)" placeholder="End">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Fade In/Out (frames)</label>
                        <div class="frame-range">
                            <input type="number" min="0" max="20" value="${overlay.fadeInFrames}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'fadeInFrames', this.value)" placeholder="Fade In">
                            <input type="number" min="0" max="20" value="${overlay.fadeOutFrames}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'fadeOutFrames', this.value)" placeholder="Fade Out">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Font Size</label>
                        <input type="number" value="${overlay.fontSize}" 
                               onchange="updateTextOverlay(${overlay.id}, 'fontSize', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Font Family</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'fontFamily', this.value)">
                            <option value="Arial" ${overlay.fontFamily === 'Arial' ? 'selected' : ''}>Arial</option>
                            <option value="Helvetica" ${overlay.fontFamily === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                            <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" ${overlay.fontFamily === '-apple-system, BlinkMacSystemFont, \'Segoe UI\', sans-serif' ? 'selected' : ''}>System (Apple/SF Pro)</option>
                            <option value="Georgia" ${overlay.fontFamily === 'Georgia' ? 'selected' : ''}>Georgia</option>
                            <option value="Times New Roman" ${overlay.fontFamily === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                            <option value="Courier New" ${overlay.fontFamily === 'Courier New' ? 'selected' : ''}>Courier New</option>
                            <option value="Verdana" ${overlay.fontFamily === 'Verdana' ? 'selected' : ''}>Verdana</option>
                            <option value="Impact" ${overlay.fontFamily === 'Impact' ? 'selected' : ''}>Impact</option>
                            ${customFonts.length > 0 ? '<option disabled>--- Custom Fonts ---</option>' : ''}
                            ${customFonts.map(font => `<option value="${font.name}" ${overlay.fontFamily === font.name ? 'selected' : ''}>${font.name}</option>`).join('')}
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Text Color</label>
                        <input type="color" value="${overlay.color}" 
                               onchange="updateTextOverlay(${overlay.id}, 'color', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Horizontal Align</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'align', this.value)">
                            <option value="left" ${overlay.align === 'left' ? 'selected' : ''}>Left</option>
                            <option value="center" ${overlay.align === 'center' ? 'selected' : ''}>Center</option>
                            <option value="right" ${overlay.align === 'right' ? 'selected' : ''}>Right</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Vertical Position</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'verticalAlign', this.value)">
                            <option value="top" ${overlay.verticalAlign === 'top' ? 'selected' : ''}>Top</option>
                            <option value="middle" ${overlay.verticalAlign === 'middle' ? 'selected' : ''}>Middle</option>
                            <option value="bottom" ${overlay.verticalAlign === 'bottom' ? 'selected' : ''}>Bottom</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Position Offset (X, Y in pixels)</label>
                        <div class="frame-range">
                            <input type="number" value="${overlay.xOffset}" step="1"
                                   onchange="updateTextOverlay(${overlay.id}, 'xOffset', this.value)" placeholder="X offset">
                            <input type="number" value="${overlay.yOffset}" step="1"
                                   onchange="updateTextOverlay(${overlay.id}, 'yOffset', this.value)" placeholder="Y offset">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Text Transform</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'textTransform', this.value)">
                            <option value="none" ${overlay.textTransform === 'none' ? 'selected' : ''}>None</option>
                            <option value="uppercase" ${overlay.textTransform === 'uppercase' ? 'selected' : ''}>UPPERCASE</option>
                            <option value="lowercase" ${overlay.textTransform === 'lowercase' ? 'selected' : ''}>lowercase</option>
                            <option value="capitalize" ${overlay.textTransform === 'capitalize' ? 'selected' : ''}>Capitalize</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Letter Spacing (px)</label>
                        <input type="number" value="${overlay.letterSpacing}" step="0.5"
                               onchange="updateTextOverlay(${overlay.id}, 'letterSpacing', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Line Height</label>
                        <input type="number" value="${overlay.lineHeight}" step="0.1" min="0.5" max="3"
                               onchange="updateTextOverlay(${overlay.id}, 'lineHeight', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Shadow Blur (px)</label>
                        <input type="number" value="${overlay.shadowBlur}" min="0" max="50"
                               onchange="updateTextOverlay(${overlay.id}, 'shadowBlur', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Shadow Color</label>
                        <input type="color" value="${overlay.shadowColor}" 
                               onchange="updateTextOverlay(${overlay.id}, 'shadowColor', this.value)">
                    </div>
                </div>
            `).join('');
        }

        function toggleLoadMethod() {
            const method = document.getElementById('loadMethod').value;
            const uploadSection = document.getElementById('uploadSection');
            const urlSection = document.getElementById('urlSection');
            
            if (method === 'upload') {
                uploadSection.style.display = 'block';
                urlSection.style.display = 'none';
            } else {
                uploadSection.style.display = 'none';
                urlSection.style.display = 'block';
            }
        }

        async function loadFromURL() {
            const pattern = document.getElementById('urlPattern').value.trim();
            if (!pattern) {
                alert('Please enter a URL pattern');
                return;
            }

            // Parse pattern like: https://example.com/images/frame{001-030}.jpg
            const match = pattern.match(/^(.+)\{(\d+)-(\d+)\}(.+)$/);
            if (!match) {
                alert('Invalid pattern. Use format: https://example.com/images/frame{001-030}.jpg');
                return;
            }

            const [, prefix, startStr, endStr, suffix] = match;
            const start = parseInt(startStr);
            const end = parseInt(endStr);
            const padding = startStr.length;

            if (start > end) {
                alert('Start number must be less than or equal to end number');
                return;
            }

            const urls = [];
            for (let i = start; i <= end; i++) {
                const numStr = String(i).padStart(padding, '0');
                urls.push(prefix + numStr + suffix);
            }

            document.getElementById('fileInfo').textContent = `Loading ${urls.length} images...`;
            
            loadedImages = [];
            let successCount = 0;
            let failCount = 0;

            for (const url of urls) {
                try {
                    const img = new Image();
                    img.crossOrigin = "anonymous"; // Enable CORS if server supports it
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            loadedImages.push(img);
                            successCount++;
                            document.getElementById('fileInfo').textContent = 
                                `Loaded ${successCount}/${urls.length} images${failCount > 0 ? ` (${failCount} failed)` : ''}`;
                            resolve();
                        };
                        img.onerror = () => {
                            failCount++;
                            document.getElementById('fileInfo').textContent = 
                                `Loaded ${successCount}/${urls.length} images${failCount > 0 ? ` (${failCount} failed)` : ''}`;
                            resolve(); // Continue even if one fails
                        };
                        img.src = url;
                    });
                } catch (err) {
                    failCount++;
                }
            }

            if (loadedImages.length === 0) {
                alert('Failed to load any images. Check the URL pattern and ensure CORS is enabled on the server.');
                document.getElementById('fileInfo').textContent = 'No images loaded';
                return;
            }

            document.getElementById('fileInfo').textContent = 
                `${successCount} images loaded successfully${failCount > 0 ? ` (${failCount} failed)` : ''}`;
            
            images = urls.slice(0, successCount);
            updatePreview();
        }

        // Update speed display
        document.getElementById('scrollSpeed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value + 'x';
        });

        // Handle file upload
        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Sort files by name
            files.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

            document.getElementById('fileInfo').textContent = `${files.length} images loaded`;
            
            images = files;
            loadedImages = [];

            // Load all images
            for (const file of files) {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => {
                    img.onload = resolve;
                });
                loadedImages.push(img);
            }

            updatePreview();
        });

        function updatePreview() {
            if (loadedImages.length === 0) return;

            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const wrapper = document.getElementById('previewWrapper');
            const scrollContent = document.getElementById('scrollContent');

            // Get config
            currentConfig.width = parseInt(document.getElementById('widthInput').value) || 800;
            currentConfig.height = parseInt(document.getElementById('heightInput').value) || 600;
            currentConfig.objectFit = document.getElementById('objectFit').value;
            currentConfig.scrollSpeed = parseFloat(document.getElementById('scrollSpeed').value);

            // Set canvas size
            canvas.width = currentConfig.width;
            canvas.height = currentConfig.height;

            // Calculate scroll height based on speed
            const scrollHeight = currentConfig.height + (loadedImages.length * 100 / currentConfig.scrollSpeed);
            scrollContent.style.height = scrollHeight + 'px';

            // Remove scroll indicator
            const indicator = scrollContent.querySelector('.scroll-indicator');
            if (indicator) indicator.style.display = 'none';

            // Render on scroll
            function renderFrame() {
                const scrollTop = wrapper.scrollTop;
                const maxScroll = scrollContent.scrollHeight - wrapper.clientHeight;
                const scrollProgress = Math.min(scrollTop / maxScroll, 1);
                
                const frameIndex = Math.floor(scrollProgress * (loadedImages.length - 1));
                const img = loadedImages[frameIndex];

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawImageWithFit(ctx, img, 0, 0, canvas.width, canvas.height, currentConfig.objectFit);
                
                // Draw text overlays
                textOverlays.forEach(overlay => {
                    if (frameIndex >= overlay.startFrame && frameIndex <= overlay.endFrame) {
                        drawTextOverlay(ctx, overlay, frameIndex, canvas.width, canvas.height);
                    }
                });
            }

            wrapper.removeEventListener('scroll', renderFrame);
            wrapper.addEventListener('scroll', renderFrame);
            
            // Initial render
            renderFrame();

            // Generate embed code
            generateEmbedCode();
        }

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;

            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x;
                    drawY = y;
                    drawWidth = width;
                    drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width;
                    drawHeight = img.height;
                    break;
            }

            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        function drawTextOverlay(ctx, overlay, currentFrame, canvasWidth, canvasHeight) {
            // Calculate opacity based on fade in/out
            let opacity = 1;
            const framesSinceStart = currentFrame - overlay.startFrame;
            const framesUntilEnd = overlay.endFrame - currentFrame;
            
            if (framesSinceStart < overlay.fadeInFrames) {
                opacity = framesSinceStart / overlay.fadeInFrames;
            } else if (framesUntilEnd < overlay.fadeOutFrames) {
                opacity = framesUntilEnd / overlay.fadeOutFrames;
            }
            
            opacity = Math.max(0, Math.min(1, opacity));
            
            // Apply text transform
            let displayText = overlay.text;
            switch(overlay.textTransform) {
                case 'uppercase':
                    displayText = displayText.toUpperCase();
                    break;
                case 'lowercase':
                    displayText = displayText.toLowerCase();
                    break;
                case 'capitalize':
                    displayText = displayText.replace(/\b\w/g, l => l.toUpperCase());
                    break;
            }
            
            // Set font and text properties
            ctx.font = `${overlay.fontSize}px ${overlay.fontFamily}`;
            ctx.globalAlpha = opacity;
            ctx.textAlign = overlay.align;
            
            // Handle letter spacing
            if (overlay.letterSpacing !== 0) {
                ctx.letterSpacing = `${overlay.letterSpacing}px`;
            }
            
            // Split text into lines
            const lines = displayText.split('\n');
            const lineHeight = overlay.fontSize * overlay.lineHeight;
            
            // Calculate vertical position
            let startY;
            const totalHeight = lines.length * lineHeight;
            switch(overlay.verticalAlign) {
                case 'top':
                    startY = overlay.fontSize + 40;
                    break;
                case 'bottom':
                    startY = canvasHeight - totalHeight - 40;
                    break;
                case 'middle':
                default:
                    startY = (canvasHeight - totalHeight) / 2 + overlay.fontSize;
                    break;
            }
            
            // Calculate horizontal position
            let textX;
            switch(overlay.align) {
                case 'left':
                    textX = 40;
                    break;
                case 'right':
                    textX = canvasWidth - 40;
                    break;
                case 'center':
                default:
                    textX = canvasWidth / 2;
                    break;
            }
            
            // Apply offsets
            textX += overlay.xOffset || 0;
            startY += overlay.yOffset || 0;
            
            // Draw each line with shadow
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                
                // Draw shadow if enabled
                if (overlay.shadowBlur > 0) {
                    ctx.shadowColor = overlay.shadowColor;
                    ctx.shadowBlur = overlay.shadowBlur;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                }
                
                // Draw fill text
                ctx.fillStyle = overlay.color;
                ctx.fillText(line, textX, y);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
            
            // Reset properties
            ctx.globalAlpha = 1;
            ctx.letterSpacing = '0px';
        }

        function generateEmbedCode() {
            const loadMethod = document.getElementById('loadMethod').value;
            const urlPattern = document.getElementById('urlPattern').value;
            
            let imagePathsComment = '';
            let imagePathsExample = '';
            
            if (loadMethod === 'url' && urlPattern) {
                imagePathsComment = '// Your URL pattern was: ' + urlPattern;
                imagePathsExample = `                // Generated from pattern
                'path/to/image001.jpg',
                'path/to/image002.jpg',
                'path/to/image003.jpg',`;
            } else {
                imagePathsComment = '// Add your image paths here';
                imagePathsExample = `                'path/to/image001.jpg',
                'path/to/image002.jpg',
                'path/to/image003.jpg',`;
            }

            // Generate custom fonts links
            const customFontsLinks = customFonts.map(font => 
                `    <link rel="stylesheet" href="${font.url}">`
            ).join('\n');

            // Generate text overlays config
            const textOverlaysConfig = textOverlays.length > 0 
                ? ',\n            textOverlays: ' + JSON.stringify(textOverlays.map(t => ({
                    text: t.text,
                    startFrame: t.startFrame,
                    endFrame: t.endFrame,
                    fadeInFrames: t.fadeInFrames,
                    fadeOutFrames: t.fadeOutFrames,
                    fontSize: t.fontSize,
                    fontFamily: t.fontFamily,
                    color: t.color,
                    align: t.align,
                    verticalAlign: t.verticalAlign,
                    textTransform: t.textTransform,
                    letterSpacing: t.letterSpacing,
                    lineHeight: t.lineHeight,
                    xOffset: t.xOffset,
                    yOffset: t.yOffset,
                    shadowBlur: t.shadowBlur,
                    shadowColor: t.shadowColor
                })), null, 12).replace(/\n/g, '\n            ')
                : '';

            const code = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
${customFontsLinks ? customFontsLinks + '\n' : ''}    <style>
        body { margin: 0; padding: 0; }
        .scroll-sequence-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        .scroll-sequence-canvas {
            position: sticky;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="scroll-sequence-container" id="sequenceContainer">
        <canvas id="sequenceCanvas" class="scroll-sequence-canvas"></canvas>
    </div>

    <script>
        const config = {
            width: ${currentConfig.width},
            height: ${currentConfig.height},
            objectFit: '${currentConfig.objectFit}',
            scrollSpeed: ${currentConfig.scrollSpeed},
            imagePaths: [
                ${imagePathsComment}
${imagePathsExample}
                // ... more images
            ]${textOverlaysConfig}
        };

        const canvas = document.getElementById('sequenceCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('sequenceContainer');
        
        canvas.width = config.width;
        canvas.height = config.height;

        const images = [];
        let imagesLoaded = 0;

        // Load images
        config.imagePaths.forEach((path, i) => {
            const img = new Image();
            img.src = path;
            img.onload = () => {
                imagesLoaded++;
                if (imagesLoaded === config.imagePaths.length) {
                    render();
                }
            };
            images.push(img);
        });

        // Set container height for scroll
        const scrollHeight = config.height + (images.length * 100 / config.scrollSpeed);
        container.style.height = scrollHeight + 'px';

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;
            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x; drawY = y;
                    drawWidth = width; drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width; drawHeight = img.height;
                    break;
            }
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        function drawTextOverlay(ctx, overlay, currentFrame, canvasWidth, canvasHeight) {
            let opacity = 1;
            const framesSinceStart = currentFrame - overlay.startFrame;
            const framesUntilEnd = overlay.endFrame - currentFrame;
            
            if (framesSinceStart < overlay.fadeInFrames) {
                opacity = framesSinceStart / overlay.fadeInFrames;
            } else if (framesUntilEnd < overlay.fadeOutFrames) {
                opacity = framesUntilEnd / overlay.fadeOutFrames;
            }
            
            opacity = Math.max(0, Math.min(1, opacity));
            
            let displayText = overlay.text;
            switch(overlay.textTransform) {
                case 'uppercase': displayText = displayText.toUpperCase(); break;
                case 'lowercase': displayText = displayText.toLowerCase(); break;
                case 'capitalize': displayText = displayText.replace(/\\b\\w/g, l => l.toUpperCase()); break;
            }
            
            ctx.font = \`\${overlay.fontSize}px \${overlay.fontFamily}\`;
            ctx.globalAlpha = opacity;
            ctx.textAlign = overlay.align;
            
            if (overlay.letterSpacing !== 0) {
                ctx.letterSpacing = \`\${overlay.letterSpacing}px\`;
            }
            
            const lines = displayText.split('\\n');
            const lineHeight = overlay.fontSize * overlay.lineHeight;
            
            let startY;
            const totalHeight = lines.length * lineHeight;
            switch(overlay.verticalAlign) {
                case 'top': startY = overlay.fontSize + 40; break;
                case 'bottom': startY = canvasHeight - totalHeight - 40; break;
                case 'middle':
                default: startY = (canvasHeight - totalHeight) / 2 + overlay.fontSize; break;
            }
            
            let textX;
            switch(overlay.align) {
                case 'left': textX = 40; break;
                case 'right': textX = canvasWidth - 40; break;
                case 'center':
                default: textX = canvasWidth / 2; break;
            }
            
            // Apply offsets
            textX += overlay.xOffset || 0;
            startY += overlay.yOffset || 0;
            
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                
                // Draw shadow if enabled
                if (overlay.shadowBlur > 0) {
                    ctx.shadowColor = overlay.shadowColor;
                    ctx.shadowBlur = overlay.shadowBlur;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                }
                
                // Draw fill text
                ctx.fillStyle = overlay.color;
                ctx.fillText(line, textX, y);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
            
            ctx.globalAlpha = 1;
            ctx.letterSpacing = '0px';
        }

        function render() {
            const scrollTop = window.pageYOffset;
            const maxScroll = container.offsetHeight - window.innerHeight;
            const scrollProgress = Math.min(scrollTop / maxScroll, 1);
            const frameIndex = Math.floor(scrollProgress * (images.length - 1));
            
            const img = images[frameIndex];
            if (img && img.complete) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawImageWithFit(ctx, img, 0, 0, canvas.width, canvas.height, config.objectFit);
                
                // Draw text overlays
                if (config.textOverlays) {
                    config.textOverlays.forEach(overlay => {
                        if (frameIndex >= overlay.startFrame && frameIndex <= overlay.endFrame) {
                            drawTextOverlay(ctx, overlay, frameIndex, canvas.width, canvas.height);
                        }
                    });
                }
            }
        }

        window.addEventListener('scroll', render);
        render();
    <\/script>
</body>
</html>`;

            document.getElementById('embedCode').value = code;
        }

        function copyCode() {
            const textarea = document.getElementById('embedCode');
            textarea.select();
            document.execCommand('copy');
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadInstructions() {
            const code = document.getElementById('embedCode').value;
            
            const instructions = `===========================================
FANTASTIC SCROLLTASTIC - EMBED CODE
===========================================

INSTRUCTIONS:
Sections marked with >>> REPLACE THIS <<< need to be updated with your values.

===========================================

${code}

===========================================
QUICK REFERENCE:
===========================================

1. Replace image paths in the imagePaths array
2. Verify width, height, objectFit, and scrollSpeed settings
3. If you have custom fonts, the <link> tags are already included
4. If you added text overlays, they're in the textOverlays array

Need help? Check the user guide documentation.
`;

            const blob = new Blob([instructions], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fantastic-scrolltastic-instructions.txt';
            link.click();
            window.URL.revokeObjectURL(url);
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Downloaded!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        // Initial code generation
        generateEmbedCode();
        updateCustomFontsList();
        checkCustomAspectRatio();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Layers</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            align-items: start;
            transition: grid-template-columns 0.3s ease;
        }

        .container.controls-hidden {
            grid-template-columns: 0 1fr;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            transform: translateX(-20px);
            pointer-events: none;
        }

        .controls::-webkit-scrollbar {
            width: 8px;
        }

        .controls::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 4px;
        }

        .controls::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 4px;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            color: #e0e0e0;
            transition: background 0.2s;
        }

        .toggle-controls:hover {
            background: #2a2a2a;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
            color: #fff;
        }

        h2 {
            font-size: 16px;
            margin: 20px 0 0 0;
            padding: 12px;
            color: #fff;
            background: #0a0a0a;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        h2:hover {
            background: #151515;
            color: #4a9eff;
        }

        h2::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.2s;
        }

        h2.collapsed::after {
            transform: rotate(-90deg);
        }

        .section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease;
            opacity: 0;
            padding-top: 0;
        }

        .section-content.expanded {
            max-height: 2000px;
            opacity: 1;
            padding-top: 16px;
        }

        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
        }

        .control-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #a0a0a0;
            font-weight: 500;
        }

        .upload-area {
            width: 100%;
            padding: 30px;
            background: #0a0a0a;
            border: 2px dashed #444;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #4a9eff;
            background: #151515;
        }

        .upload-area.dragover {
            border-color: #4a9eff;
            background: #1a2a3a;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .upload-text {
            font-size: 14px;
            color: #e0e0e0;
            margin-bottom: 8px;
        }

        .upload-hint {
            font-size: 11px;
            color: #666;
        }

        input[type="file"] {
            display: none;
        }

        input[type="number"],
        input[type="text"],
        input[type="color"],
        select,
        textarea {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            cursor: pointer;
        }

        .range-value {
            float: right;
            color: #888;
            font-size: 12px;
        }

        .split-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 10px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:disabled {
            background: #2a2a2a;
            color: #666;
            cursor: not-allowed;
        }

        button.secondary {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        button.secondary:hover {
            background: #3a3a3a;
        }

        textarea {
            min-height: 200px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .layer-item {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            transition: border-color 0.2s;
        }

        .layer-item:hover {
            border-color: #4a9eff;
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .layer-name {
            font-size: 12px;
            color: #4a9eff;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
        }

        .icon-btn {
            background: #2a2a2a;
            border: none;
            padding: 3px 6px;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.2s;
        }

        .icon-btn:hover {
            background: #3a3a3a;
        }

        .layer-details {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: max-height 0.3s ease-out;
            padding-top: 10px;
            padding-bottom: 10px;
        }

        .layer-details.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        /* Text input modal */
        .text-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        
        .text-modal.active {
            display: flex;
        }
        
        .text-modal-content {
            background: #1a1a1a;
            border: 2px solid #4a9eff;
            border-radius: 8px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
        }
        
        .text-modal h3 {
            margin: 0 0 16px 0;
            color: #4a9eff;
            font-size: 18px;
        }
        
        .text-modal textarea {
            width: 100%;
            padding: 12px;
            background: #0a0a0a;
            border: 1px solid #4a9eff;
            color: #fff;
            border-radius: 4px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            resize: vertical;
            min-height: 80px;
        }
        
        .text-modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }
        
        .text-modal button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .text-modal .btn-create {
            background: #4a9eff;
            color: #000;
        }
        
        .text-modal .btn-cancel {
            background: #2a2a2a;
            color: #999;
        }

        .layer-thumb {
            width: 100%;
            height: 60px;
            object-fit: contain;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #000;
        }

        .preview-panel {
            background: #000;
            border-radius: 12px;
            border: 1px solid #2a2a2a;
            padding: 0;
            overflow: hidden;
            position: relative;
        }

        .preview-wrapper {
            height: calc(100vh - 40px);
            overflow-y: auto;
            position: relative;
        }

        .preview-wrapper::-webkit-scrollbar {
            width: 12px;
        }

        .preview-wrapper::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .preview-wrapper::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 6px;
        }

        .scroll-content {
            position: relative;
        }

        .viewport-container {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .viewport-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 98%;
        }

        .viewport {
            position: relative;
            width: 100%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .caption-overlay {
            position: relative;
            width: 85%;
            max-width: 700px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.9);
            font-size: 13px;
            line-height: 1.5;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 20;
            color: #e0e0e0;
        }

        .caption-overlay.visible {
            opacity: 1;
        }

        .caption-credit {
            color: #999;
            font-size: 11px;
            font-style: italic;
            margin-top: 4px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            background: #1a1a1a;
            padding: 30px 40px;
            border-radius: 12px;
            border: 1px solid #2a2a2a;
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #2a2a2a;
            border-top-color: #4a9eff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #e0e0e0;
            font-size: 14px;
        }

        .info-box {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 12px;
            font-size: 11px;
            color: #888;
            line-height: 1.5;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
        }

        .effect-preset {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .effect-preset:hover {
            border-color: #4a9eff;
            background: #0f1a2a;
        }

        .effect-preset.active {
            border-color: #4a9eff;
            background: #0f1a2a;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="toggle-controls" onclick="toggleControls()">‚ò∞ Controls</div>

    <div class="container" id="container">
        <div class="panel controls" id="controls">
            <h1>Scrolltastic Layers</h1>
            
            <h2 onclick="toggleSection(this)">Load Layers</h2>
            <div class="section-content">
                <div class="control-group">
                    <button class="secondary" onclick="loadExampleLayers()" id="loadExampleBtn">Load Example Layers</button>
                    <button class="secondary" onclick="addTextLayer();" id="addTextBtn" style="background: #4a9eff; color: #000; font-weight: 600;">‚ûï Add Text Layer</button>
                    <button class="secondary" onclick="clearAllLayers()" id="clearBtn" disabled>Clear All Layers</button>
                </div>
                <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Upload Layer Images</div>
                    <div class="upload-hint">PNG, JPG ‚Ä¢ Stacks like Photoshop</div>
                </div>
                <input type="file" id="fileInput" multiple accept="image/*" onchange="handleFileUpload(event)">
                
                <div style="margin-top: 16px; padding: 16px; background: #1a1a1a; border: 2px dashed #4a9eff; border-radius: 8px;">
                    <div style="font-size: 13px; color: #4a9eff; margin-bottom: 8px; font-weight: 600;">üîó Load Image from URL</div>
                    <div style="font-size: 11px; color: #999; margin-bottom: 12px;">Paste a direct link to any PNG, JPG, or GIF image</div>
                    <div style="display: flex; gap: 8px;">
                        <input type="url" id="imageUrlInput" placeholder="https://example.com/image.png" 
                               style="flex: 1; padding: 10px; background: #0a0a0a; border: 1px solid #4a9eff; color: #fff; border-radius: 4px; font-size: 13px;"
                               onkeypress="if(event.key==='Enter') loadImageFromUrl()">
                        <button onclick="loadImageFromUrl()" style="padding: 10px 20px; background: #4a9eff; border: none; color: #000; font-weight: 600; cursor: pointer; border-radius: 4px; font-size: 13px;">Load Image</button>
                    </div>
                </div>
            </div>

            <h2 onclick="toggleSection(this)">Custom Fonts</h2>
            <div class="section-content">
                <div class="control-group">
                    <label>Font Family for Text Layers</label>
                    <select id="fontFamily" onchange="updateGlobalFont()" style="width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #333; color: #fff; border-radius: 4px; margin-top: 8px;">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Impact">Impact</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>
                
                <div class="control-group" style="margin-top: 12px;">
                    <label>Or Upload Custom Font (TTF, OTF, WOFF)</label>
                    <input type="file" id="fontInput" accept=".ttf,.otf,.woff,.woff2" onchange="handleFontUpload(event)" style="display: none;">
                    <button onclick="document.getElementById('fontInput').click()" style="width: 100%; margin-top: 8px; padding: 10px; background: #2a2a2a; border: 1px solid #4a9eff; color: #4a9eff; cursor: pointer; border-radius: 4px; font-size: 13px; font-weight: 600;">üì§ Upload Font File</button>
                    <div id="fontStatus" style="font-size: 11px; color: #666; margin-top: 6px; text-align: center;">Using: Arial</div>
                </div>
            </div>

            <h2 onclick="toggleSection(this)">Canvas & Display</h2>
            <div class="section-content">
                <div class="control-group">
                    <label>Aspect Ratio <span style="font-size: 10px; color: #666;">(Auto-detected)</span></label>
                    <select id="aspectRatio" onchange="updateAspectRatio()">
                        <option value="auto">Auto (From Layers)</option>
                        <option value="16:9">16:9 Widescreen</option>
                        <option value="9:16">9:16 Portrait</option>
                        <option value="4:3">4:3 Standard</option>
                        <option value="1:1">1:1 Square</option>
                        <option value="21:9">21:9 Ultrawide</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>

                <div class="control-group" id="customSizeGroup" style="display: none;">
                    <label>Custom Size</label>
                    <div class="split-inputs">
                        <input type="number" id="canvasWidth" value="1920" onchange="updateCanvas()">
                        <input type="number" id="canvasHeight" value="1080" onchange="updateCanvas()">
                    </div>
                </div>

                <div class="control-group">
                    <label>Image Fit</label>
                    <select id="imageFit" onchange="render()">
                        <option value="cover">Cover (Fill, may crop)</option>
                        <option value="contain">Contain (Fit all, may have bars)</option>
                        <option value="fill">Fill (Stretch to fit)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Background</label>
                    <input type="color" id="bgColor" value="#000000" onchange="render()">
                </div>
            </div>

            <h2 onclick="toggleSection(this)">Global Effects <span style="font-size: 11px; color: #666;">(All Layers)</span></h2>
            <div class="section-content">
                <div class="control-group">
                    <label>Effect Preset</label>
                    <div class="effect-preset active" onclick="selectEffect('parallax')">
                        <strong>Parallax Depth</strong> - Layers move at different speeds
                    </div>
                    <div class="effect-preset" onclick="selectEffect('zoom')">
                        <strong>Zoom In</strong> - Entire stack zooms while scrolling
                    </div>
                    <div class="effect-preset" onclick="selectEffect('zoom-out')">
                        <strong>Zoom Out</strong> - Stack starts large, zooms out
                    </div>
                    <div class="effect-preset" onclick="selectEffect('blur-reveal')">
                        <strong>Blur Reveal</strong> - Blurred to sharp focus
                    </div>
                    <div class="effect-preset" onclick="selectEffect('fade-in')">
                        <strong>Fade In Stack</strong> - All layers fade in together
                    </div>
                    <div class="effect-preset" onclick="selectEffect('cascade')">
                        <strong>Cascade</strong> - Layers appear one by one
                    </div>
                    <div class="effect-preset" onclick="selectEffect('slide-up')">
                        <strong>Slide Up</strong> - Stack slides into view
                    </div>
                </div>

                <div class="control-group">
                    <label>Effect Intensity <span class="range-value" id="intensityValue">1.0</span></label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="range" id="effectIntensity" min="0" max="2" value="1" step="0.1" oninput="updateIntensity()" style="flex: 1;">
                        <input type="number" id="effectIntensityNum" min="0" max="2" value="1" step="0.1" oninput="syncIntensityFromNumber(this.value)" style="width: 70px;">
                    </div>
                </div>

                <div class="control-group">
                    <label>Scroll Duration (px) <span class="range-value" id="scrollValue">5000</span></label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="range" id="scrollDuration" min="2000" max="20000" value="5000" step="100" oninput="updateScrollValue()" style="flex: 1;">
                        <input type="number" id="scrollDurationNum" min="2000" max="20000" value="5000" step="100" oninput="syncScrollFromNumber(this.value)" style="width: 80px;">
                    </div>
                </div>
            </div>

            <h2 onclick="toggleSection(this)">Caption</h2>
            <div class="section-content">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="captionEnabled" onchange="render()"> Enable Caption
                    </label>
                </div>

                <div class="control-group">
                    <label>Caption Text</label>
                    <textarea id="captionText" placeholder="Your caption text..." style="min-height: 80px;">Caption goes here, Parallax depth creates immersive scroll storytelling</textarea>
                </div>

                <div class="control-group">
                    <label>Caption Credit/Source</label>
                    <input type="text" id="captionCredit" placeholder="Photo by..." value="Caption credit">
                </div>

                <div class="control-group">
                    <label>Show Caption At (%)</label>
                    <div class="split-inputs">
                        <input type="number" id="captionStart" value="20" min="0" max="100">
                        <input type="number" id="captionEnd" value="60" min="0" max="100">
                    </div>
                </div>
            </div>

            <h2 onclick="toggleSection(this)" class="collapsed">Layers <span id="layerCount" style="font-size: 11px; color: #666;">(0)</span></h2>
            <div class="section-content collapsed" id="layersList">
                <div class="info-box">
                    Upload images to see layers here. Layers stack like Photoshop.
                </div>
            </div>

            <h2 onclick="toggleSection(this)" class="collapsed">Export</h2>
            <div class="section-content collapsed">
                <div class="control-group">
                    <button onclick="generateEmbedCode()" id="generateBtn" disabled>Generate HTML</button>
                    <button class="secondary" onclick="saveProject()">Save Project</button>
                    <button class="secondary" onclick="loadProject()">Load Project</button>
                </div>

                <div class="control-group">
                    <label>Embed Code</label>
                    <textarea id="embedCode" readonly></textarea>
                    <button class="secondary" onclick="copyCode()">Copy Code</button>
                    <button class="secondary" onclick="downloadHTML()">Download HTML</button>
                </div>
            </div>
        </div>

        <div class="preview-panel">
            <div class="preview-wrapper" id="previewWrapper">
                <div class="scroll-content" id="scrollContent">
                    <div class="viewport-container">
                        <div class="viewport-wrapper">
                            <div class="viewport" id="viewport">
                                <canvas id="canvas"></canvas>
                            </div>
                            <div class="caption-overlay" id="captionOverlay">
                                <div id="captionTextDisplay"></div>
                                <div class="caption-credit" id="captionCreditDisplay"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loadingText">Processing...</div>
        </div>
    </div>

    <!-- Text Layer Modal -->
    <div class="text-modal" id="textModal">
        <div class="text-modal-content">
            <h3>Create Text Layer</h3>
            <textarea id="textInput" placeholder="Enter your text here..." autofocus></textarea>
            <div class="text-modal-buttons">
                <button class="btn-cancel" onclick="closeTextModal()">Cancel</button>
                <button class="btn-create" onclick="createTextFromModal()">Create Layer</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const previewWrapper = document.getElementById('previewWrapper');
        const scrollContent = document.getElementById('scrollContent');
        const viewport = document.getElementById('viewport');
        const uploadArea = document.getElementById('uploadArea');

        let layers = [];
        let globalEffect = 'parallax';
        let effectIntensity = 1.0;
        let config = {
            width: 1920,
            height: 1080,
            aspectRatio: 'auto',
            bgColor: '#000000',
            imageFit: 'cover',
            scrollDuration: 5000,
            captionEnabled: false,
            captionText: 'Caption goes here, Parallax depth creates immersive scroll storytelling',
            captionCredit: 'Caption credit',
            captionStart: 20,
            captionEnd: 60
        };

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
            if (files.length > 0) {
                handleFiles(files);
            }
        });

        function toggleControls() {
            document.getElementById('container').classList.toggle('controls-hidden');
            document.getElementById('controls').classList.toggle('hidden');
        }

        function toggleSection(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
            } else {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
            }
        }

        function selectEffect(effect) {
            globalEffect = effect;
            document.querySelectorAll('.effect-preset').forEach(el => el.classList.remove('active'));
            event.target.closest('.effect-preset').classList.add('active');
            render();
        }

        function updateIntensity() {
            effectIntensity = parseFloat(document.getElementById('effectIntensity').value);
            document.getElementById('intensityValue').textContent = effectIntensity.toFixed(1);
            document.getElementById('effectIntensityNum').value = effectIntensity;
            render();
        }

        function syncIntensityFromNumber(value) {
            document.getElementById('effectIntensity').value = value;
            updateIntensity();
        }

        function updateScrollValue() {
            config.scrollDuration = parseInt(document.getElementById('scrollDuration').value);
            document.getElementById('scrollValue').textContent = config.scrollDuration;
            document.getElementById('scrollDurationNum').value = config.scrollDuration;
            scrollContent.style.height = config.scrollDuration + 'px';
            render();
        }

        function syncScrollFromNumber(value) {
            document.getElementById('scrollDuration').value = value;
            updateScrollValue();
        }

        function updateAspectRatio() {
            config.aspectRatio = document.getElementById('aspectRatio').value;
            const customGroup = document.getElementById('customSizeGroup');
            
            if (config.aspectRatio === 'custom') {
                customGroup.style.display = 'block';
            } else {
                customGroup.style.display = 'none';
            }
            
            updateCanvas();
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                handleFiles(files);
            }
        }

        async function handleFiles(files) {
            showLoading('Loading layers...');

            let maxWidth = 0;
            let maxHeight = 0;
            const loadedImages = [];

            for (const file of files) {
                const dataUrl = await readFileAsDataURL(file);
                const img = await loadImage(dataUrl);
                loadedImages.push({ img, dataUrl, name: file.name });
                maxWidth = Math.max(maxWidth, img.width);
                maxHeight = Math.max(maxHeight, img.height);
            }

            // Auto-detect aspect ratio
            if (config.aspectRatio === 'auto') {
                config.width = maxWidth;
                config.height = maxHeight;
            }

            document.getElementById('canvasWidth').value = maxWidth;
            document.getElementById('canvasHeight').value = maxHeight;

            // Create layers - stacked centered
            for (let i = 0; i < loadedImages.length; i++) {
                const { img, dataUrl, name } = loadedImages[i];

                const layer = {
                    id: Date.now() + i,
                    name: name.replace(/\.[^/.]+$/, ""),
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    
                    left: (config.width - img.width) / 2,
                    top: (config.height - img.height) / 2,
                    width: img.width,
                    height: img.height,
                    
                    depth: (i / Math.max(loadedImages.length - 1, 1)),
                    scale: 1,
                    rotation: 0
                };

                layers.push(layer);
            }

            updateCanvas();
            updateLayersList();
            hideLoading();
        }

        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function updateCanvas() {
            const aspectRatio = document.getElementById('aspectRatio').value;
            
            if (aspectRatio === 'custom') {
                config.width = parseInt(document.getElementById('canvasWidth').value);
                config.height = parseInt(document.getElementById('canvasHeight').value);
            } else if (aspectRatio !== 'auto' && layers.length > 0) {
                const ratios = {
                    '16:9': [16, 9],
                    '9:16': [9, 16],
                    '4:3': [4, 3],
                    '1:1': [1, 1],
                    '21:9': [21, 9]
                };
                
                if (ratios[aspectRatio]) {
                    const [w, h] = ratios[aspectRatio];
                    const baseWidth = Math.max(...layers.map(l => l.width));
                    config.width = baseWidth;
                    config.height = Math.round(baseWidth * h / w);
                }
            }
            
            canvas.width = config.width;
            canvas.height = config.height;
            
            // Set viewport dimensions based on aspect ratio
            const viewportAspect = config.width / config.height;
            viewport.style.aspectRatio = `${config.width} / ${config.height}`;
            viewport.style.width = '100%';
            viewport.style.height = 'auto';
            
            scrollContent.style.height = config.scrollDuration + 'px';
            
            render();
        }

        function updateLayersList() {
            const list = document.getElementById('layersList');
            document.getElementById('layerCount').textContent = `(${layers.length})`;
            
            // Update button states based on layer count
            const hasLayers = layers.length > 0;
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            if (generateBtn) {
                generateBtn.disabled = !hasLayers;
            }
            if (clearBtn) {
                clearBtn.disabled = !hasLayers;
            }
            
            if (layers.length === 0) {
                list.innerHTML = '<div class="info-box">Upload images to see layers here.</div>';
                return;
            }

            list.innerHTML = '';
            
            layers.forEach((layer, index) => {
                const item = document.createElement('div');
                item.className = 'layer-item';
                
                const detailsId = `layer-details-${index}`;
                
                item.innerHTML = `
                    <div class="layer-header" onclick="toggleLayerDetails('${detailsId}')">
                        <div class="layer-name">
                            üñºÔ∏è ${layer.name}
                        </div>
                        <div class="layer-controls" onclick="event.stopPropagation()">
                            <button class="icon-btn" onclick="moveLayer(${index}, -1)" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                            <button class="icon-btn" onclick="moveLayer(${index}, 1)" ${index === layers.length - 1 ? 'disabled' : ''}>‚Üì</button>
                            <button class="icon-btn" onclick="toggleLayerVisibility(${index})">${layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}</button>
                            <button class="icon-btn" onclick="deleteLayer(${index})">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="layer-details collapsed" id="${detailsId}">
                        ${!layer.isText ? `
                        <img src="${layer.dataUrl}" class="layer-thumb" alt="${layer.name}">
                        <div style="font-size: 10px; color: #666;">
                            Size: ${layer.width}x${layer.height} ‚Ä¢ Depth: ${(layer.depth * 100).toFixed(0)}%
                        </div>
                        ` : ''}
                        ${layer.isText ? `
                        <div style="margin-top: 8px; padding: 12px; background: #1a1a1a; border-radius: 4px;">
                            <div style="font-size: 11px; color: #4a9eff; margin-bottom: 12px; font-weight: 600;">üìù Text Layer Controls</div>
                            
                            <div style="margin-bottom: 12px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 4px;">Text Content</label>
                                <textarea id="textContent-${index}" style="width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #333; color: #fff; border-radius: 3px; font-size: 11px; resize: vertical; min-height: 60px; font-family: monospace;">${layer.textContent || ''}</textarea>
                                <button onclick="updateTextContent(${index})" style="width: 100%; margin-top: 6px; padding: 8px; background: #4a9eff; border: none; color: #000; font-weight: 600; cursor: pointer; border-radius: 3px; font-size: 11px;">Update Text</button>
                            </div>
                            
                            <div style="margin-bottom: 12px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 6px;">Position X: <span id="textX-${index}" style="color: #4a9eff; font-weight: 600;">${layer.textX || 50}</span>%</label>
                                <input type="range" min="0" max="100" step="1" value="${layer.textX || 50}"
                                       oninput="updateTextPositionLive(${index}, 'x', this.value)"
                                       style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 12px;">
                                <label style="font-size: 10px; display: block; margin-bottom: 6px;">Position Y: <span id="textY-${index}" style="color: #4a9eff; font-weight: 600;">${layer.textY || 50}</span>%</label>
                                <input type="range" min="0" max="100" step="1" value="${layer.textY || 50}"
                                       oninput="updateTextPositionLive(${index}, 'y', this.value)"
                                       style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="font-size: 10px; display: block; margin-bottom: 6px;">Scale: <span id="textScale-${index}" style="color: #4a9eff; font-weight: 600;">${layer.textScale || 100}</span>%</label>
                                <input type="range" min="10" max="300" step="10" value="${layer.textScale || 100}"
                                       oninput="updateTextScaleLive(${index}, this.value)"
                                       style="width: 100%;">
                            </div>
                        </div>
                        ` : ''}
                        <div style="margin-top: 8px;">
                            <label style="font-size: 11px;">Opacity</label>
                            <input type="range" min="0" max="1" step="0.1" value="${layer.opacity}" 
                                   oninput="updateLayerOpacity(${index}, this.value)" 
                                   style="width: 100%; margin-top: 4px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <label style="font-size: 11px;">Depth (Parallax)</label>
                            <input type="range" min="0" max="2" step="0.1" value="${layer.depth}" 
                                   oninput="updateLayerDepth(${index}, this.value)" 
                                   style="width: 100%; margin-top: 4px;">
                        </div>
                        <div style="margin-top: 8px;">
                            <label style="font-size: 11px;">Scroll Speed: <span style="color: #4a9eff;">${((layer.scrollSpeed || 1) * 100).toFixed(0)}%</span></label>
                            <input type="range" min="0.5" max="2" step="0.1" value="${layer.scrollSpeed || 1}" 
                                   oninput="updateLayerScrollSpeed(${index}, this.value)" 
                                   style="width: 100%; margin-top: 4px;">
                            <div style="font-size: 9px; color: #666; margin-top: 2px;">50% = slower, 100% = normal, 200% = faster</div>
                        </div>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function toggleLayerDetails(id) {
            document.getElementById(id).classList.toggle('collapsed');
        }

        function moveLayer(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= layers.length) return;
            [layers[index], layers[newIndex]] = [layers[newIndex], layers[index]];
            updateLayersList();
            render();
        }

        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            updateLayersList();
            render();
        }

        function updateLayerOpacity(index, value) {
            layers[index].opacity = parseFloat(value);
            render();
        }

        function updateLayerDepth(index, value) {
            layers[index].depth = parseFloat(value);
            render();
        }

        function updateLayerScrollSpeed(index, value) {
            const speed = parseFloat(value);
            layers[index].scrollSpeed = speed;
            
            // Update the display label
            const label = document.querySelector(`#layer-details-${index} label`);
            if (label && label.textContent.includes('Scroll Speed')) {
                const speedPercent = (speed * 100).toFixed(0);
                label.innerHTML = `Scroll Speed: <span style="color: #4a9eff;">${speedPercent}%</span>`;
            }
            
            render();
        }

        function deleteLayer(index) {
            if (confirm('Delete this layer?')) {
                layers.splice(index, 1);
                updateLayersList();
                render();
            }
        }

        async function loadImageFromUrl() {
            const url = document.getElementById('imageUrlInput').value.trim();
            if (!url) {
                alert('Please enter an image URL');
                return;
            }
            
            showLoading('Loading image from URL...');
            
            try {
                const img = await loadImage(url);
                
                const layer = {
                    id: Date.now(),
                    name: 'URL Image',
                    image: img,
                    dataUrl: url,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: img.width,
                    height: img.height,
                    depth: layers.length > 0 ? layers.length / 10 : 0,
                    scale: 1,
                    rotation: 0
                };
                
                layers.push(layer);
                
                // Auto-detect canvas size if first layer
                if (layers.length === 1) {
                    config.width = img.width;
                    config.height = img.height;
                    document.getElementById('canvasWidth').value = img.width;
                    document.getElementById('canvasHeight').value = img.height;
                }
                
                updateCanvas();
                updateLayersList();
                hideLoading();
                
                document.getElementById('imageUrlInput').value = '';
            } catch (error) {
                hideLoading();
                alert('Error loading image from URL: ' + error.message);
            }
        }

        let customFont = null;
        let customFontName = 'CustomFont';
        let globalFontFamily = 'Arial';

        function updateGlobalFont() {
            const select = document.getElementById('fontFamily');
            globalFontFamily = select.value;
            document.getElementById('fontStatus').textContent = `Using: ${globalFontFamily}`;
            
        }

        function handleFontUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const fontFace = new FontFace(customFontName, `url(${e.target.result})`);
                fontFace.load().then(function(loadedFont) {
                    document.fonts.add(loadedFont);
                    customFont = customFontName;
                    globalFontFamily = customFontName;
                    document.getElementById('fontStatus').textContent = `‚úì Custom font loaded: ${file.name}`;
                    document.getElementById('fontStatus').style.color = '#4a9eff';
                    
                    // Add to dropdown
                    const select = document.getElementById('fontFamily');
                    const option = new Option(customFontName, customFontName);
                    select.add(option);
                    select.value = customFontName;
                }).catch(function(error) {
                    alert('Error loading font: ' + error.message);
                });
            };
            reader.readAsDataURL(file);
        }

        function updateTextContent(index) {
            const layer = layers[index];
            if (!layer.isText) return;
            
            const textarea = document.getElementById(`textContent-${index}`);
            const newText = textarea.value.trim();
            
            if (!newText) {
                alert('Text cannot be empty');
                return;
            }
            
            layer.name = `Text: ${newText.substring(0, 20)}`;
            layer.textContent = newText;
            
            // Regenerate text layer without collapsing
            regenerateTextLayer(layer, index);
        }

        function updateTextPositionLive(index, axis, value) {
            const layer = layers[index];
            if (!layer.isText) return;
            
            if (axis === 'x') {
                layer.textX = parseFloat(value);
                document.getElementById(`textX-${index}`).textContent = value;
            } else {
                layer.textY = parseFloat(value);
                document.getElementById(`textY-${index}`).textContent = value;
            }
            
            // Regenerate without collapsing
            regenerateTextLayer(layer, index);
        }

        function updateTextScaleLive(index, value) {
            const layer = layers[index];
            if (!layer.isText) return;
            
            layer.textScale = parseFloat(value);
            document.getElementById(`textScale-${index}`).textContent = value;
            
            // Regenerate without collapsing
            regenerateTextLayer(layer, index);
        }

        function regenerateTextLayer(layer, index) {
            // Regenerate text layer image without refreshing the entire list
            const width = layer.width;
            const height = layer.height;
            const text = layer.textContent;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const ctx = tempCanvas.getContext('2d');
            
            ctx.clearRect(0, 0, width, height);
            
            const posX = (layer.textX / 100) * width;
            const posY = (layer.textY / 100) * height;
            const scaleFactor = layer.textScale / 100;
            
            ctx.save();
            ctx.translate(posX, posY);
            ctx.scale(scaleFactor, scaleFactor);
            
            const fontFamily = customFont || globalFontFamily;
            ctx.font = `bold ${layer.fontSize}px ${fontFamily}`;
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 4;
            
            ctx.fillText(text, 0, 0);
            ctx.restore();
            
            const dataUrl = tempCanvas.toDataURL('image/png');
            
            const img = new Image();
            img.onload = function() {
                layer.image = img;
                layer.dataUrl = dataUrl;
                render(); // Only re-render canvas, don't refresh layer list
            };
            img.src = dataUrl;
        }

        function addTextLayer() {
            
            
            // Open modal instead of prompt
            const modal = document.getElementById('textModal');
            const input = document.getElementById('textInput');
            
            modal.classList.add('active');
            input.value = 'Your Text Here';
            input.focus();
            input.select();
            
            
        }
        
        function closeTextModal() {
            const modal = document.getElementById('textModal');
            modal.classList.remove('active');
            
        }
        
        function createTextFromModal() {
            const input = document.getElementById('textInput');
            const text = input.value.trim();
            
            
            
            if (!text) {
                alert('Please enter some text');
                return;
            }
            
            closeTextModal();
            showLoading('Creating text layer...');
            
            // Simple approach - just create it directly
            setTimeout(() => {
                
                
                // Get canvas size from inputs
                const width = parseInt(document.getElementById('canvasWidth').value) || 1920;
                const height = parseInt(document.getElementById('canvasHeight').value) || 1080;
                
                
                
                // Create a canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const ctx = tempCanvas.getContext('2d');
                
                // Clear to transparent
                ctx.clearRect(0, 0, width, height);
                
                // Draw text
                const fontSize = Math.floor(height / 10);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;
                
                ctx.fillText(text, width / 2, height / 2);
                
                
                
                // Get data URL
                const dataUrl = tempCanvas.toDataURL('image/png');
                
                
                // Create image
                const img = new Image();
                
                img.onload = function() {
                    
                    
                    const newLayer = {
                        id: Date.now(),
                        name: 'Text: ' + text.substring(0, 20),
                        image: img,
                        dataUrl: dataUrl,
                        visible: true,
                        opacity: 1,
                        left: 0,
                        top: 0,
                        width: width,
                        height: height,
                        depth: 1,
                        scale: 1,
                        rotation: 0,
                        isText: true,
                        textContent: text,
                        textX: 50,
                        textY: 50,
                        textScale: 100,
                        fontSize: fontSize
                    };
                    
                    
                    
                    // Add to layers array
                    layers.push(newLayer);
                    
                    
                    // Update UI
                    updateCanvas();
                    
                    
                    updateLayersList();
                    
                    
                    hideLoading();
                    
                };
                
                img.onerror = function(err) {
                    hideLoading();
                    alert('Failed to load text image');
                };
                
                
                img.src = dataUrl;
                
            }, 150);
        }

        function createTextLayerSync(text, existingLayer = null) {
            
            
            // Get canvas dimensions - check multiple sources
            let canvasWidth = config.width;
            let canvasHeight = config.height;
            
            if (!canvasWidth || !canvasHeight) {
                canvasWidth = parseInt(document.getElementById('canvasWidth').value) || 1920;
                canvasHeight = parseInt(document.getElementById('canvasHeight').value) || 1080;
            }
            
            
            
            // Create text canvas
            const textCanvas = document.createElement('canvas');
            textCanvas.width = canvasWidth;
            textCanvas.height = canvasHeight;
            const textCtx = textCanvas.getContext('2d');
            
            // Get text properties
            const textX = existingLayer?.textX || 50;
            const textY = existingLayer?.textY || 50;
            const textScale = existingLayer?.textScale || 100;
            const fontSize = existingLayer?.fontSize || Math.floor(canvasHeight / 10);
            
            
            
            // Clear canvas (transparent background)
            textCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Calculate position
            const posX = (textX / 100) * canvasWidth;
            const posY = (textY / 100) * canvasHeight;
            const scaleFactor = textScale / 100;
            
            // Apply transformations
            textCtx.save();
            textCtx.translate(posX, posY);
            textCtx.scale(scaleFactor, scaleFactor);
            
            // Set text style
            const fontFamily = customFont || globalFontFamily;
            textCtx.font = `bold ${fontSize}px ${fontFamily}`;
            textCtx.fillStyle = '#ffffff';
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            
            // Add shadow
            textCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            textCtx.shadowBlur = 20;
            textCtx.shadowOffsetX = 4;
            textCtx.shadowOffsetY = 4;
            
            // Draw text
            textCtx.fillText(text, 0, 0);
            textCtx.restore();
            
            
            
            // Convert to data URL
            const dataUrl = textCanvas.toDataURL('image/png');
            
            
            // Create image from data URL
            const img = new Image();
            img.onload = () => {
                
                
                if (existingLayer) {
                    // Update existing layer
                    existingLayer.image = img;
                    existingLayer.dataUrl = dataUrl;
                    existingLayer.textContent = text;
                    
                } else {
                    // Create new layer
                    const layer = {
                        id: Date.now(),
                        name: `Text: ${text.substring(0, 20)}`,
                        image: img,
                        dataUrl: dataUrl,
                        visible: true,
                        opacity: 1,
                        left: 0,
                        top: 0,
                        width: canvasWidth,
                        height: canvasHeight,
                        depth: 1,
                        scale: 1,
                        rotation: 0,
                        isText: true,
                        textContent: text,
                        textX: textX,
                        textY: textY,
                        textScale: textScale,
                        fontSize: fontSize
                    };
                    
                    layers.push(layer);
                    
                }
                
                updateCanvas();
                updateLayersList();
                hideLoading();
                
            };
            
            img.onerror = (error) => {
                
                hideLoading();
                alert('Failed to create text layer image');
            };
            
            img.src = dataUrl;
        }

        function clearAllLayers() {
            if (layers.length === 0) return;
            
            layers.splice(0, layers.length);
            updateLayersList();
            render();
        }

        async function loadExampleLayers() {
            showLoading('Creating example layers...');

            const exampleLayers = [];
            const layerWidth = 1920;
            const layerHeight = 1080;

            config.width = layerWidth;
            config.height = layerHeight;
            document.getElementById('canvasWidth').value = layerWidth;
            document.getElementById('canvasHeight').value = layerHeight;

            // Layer 1: Deep Background - Starfield
            {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = layerWidth;
                tempCanvas.height = layerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Dark gradient background
                const gradient = tempCtx.createLinearGradient(0, 0, 0, layerHeight);
                gradient.addColorStop(0, '#0a0a1f');
                gradient.addColorStop(1, '#1a1a3e');
                tempCtx.fillStyle = gradient;
                tempCtx.fillRect(0, 0, layerWidth, layerHeight);

                // Stars
                for (let i = 0; i < 200; i++) {
                    tempCtx.fillStyle = 'rgba(255, 255, 255, ' + (Math.random() * 0.5 + 0.2) + ')';
                    tempCtx.beginPath();
                    tempCtx.arc(
                        Math.random() * layerWidth,
                        Math.random() * layerHeight,
                        Math.random() * 2,
                        0,
                        Math.PI * 2
                    );
                    tempCtx.fill();
                }

                const dataUrl = tempCanvas.toDataURL();
                const img = await loadImage(dataUrl);
                exampleLayers.push({
                    id: Date.now(),
                    name: 'Background Stars',
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: layerWidth,
                    height: layerHeight,
                    depth: 0,
                    scale: 1,
                    rotation: 0
                });
            }

            // Layer 2: Distant Mountains
            {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = layerWidth;
                tempCanvas.height = layerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Mountain silhouettes
                tempCtx.fillStyle = 'rgba(30, 40, 80, 0.8)';
                tempCtx.beginPath();
                tempCtx.moveTo(0, layerHeight);
                tempCtx.lineTo(0, layerHeight * 0.6);
                tempCtx.quadraticCurveTo(layerWidth * 0.2, layerHeight * 0.4, layerWidth * 0.35, layerHeight * 0.55);
                tempCtx.quadraticCurveTo(layerWidth * 0.5, layerHeight * 0.7, layerWidth * 0.65, layerHeight * 0.5);
                tempCtx.quadraticCurveTo(layerWidth * 0.8, layerHeight * 0.3, layerWidth, layerHeight * 0.65);
                tempCtx.lineTo(layerWidth, layerHeight);
                tempCtx.closePath();
                tempCtx.fill();

                const dataUrl = tempCanvas.toDataURL();
                const img = await loadImage(dataUrl);
                exampleLayers.push({
                    id: Date.now() + 1,
                    name: 'Distant Mountains',
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: layerWidth,
                    height: layerHeight,
                    depth: 0.3,
                    scale: 1,
                    rotation: 0
                });
            }

            // Layer 3: Midground - Floating Islands
            {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = layerWidth;
                tempCanvas.height = layerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw floating islands
                const islands = [
                    { x: 200, y: 300, w: 180, h: 80 },
                    { x: 600, y: 450, w: 220, h: 100 },
                    { x: 1200, y: 350, w: 200, h: 90 },
                    { x: 1600, y: 500, w: 160, h: 70 }
                ];

                islands.forEach(island => {
                    // Island shape
                    tempCtx.fillStyle = '#4a5568';
                    tempCtx.beginPath();
                    tempCtx.ellipse(island.x, island.y, island.w / 2, island.h / 2, 0, 0, Math.PI * 2);
                    tempCtx.fill();

                    // Grass on top
                    tempCtx.fillStyle = '#2d3748';
                    tempCtx.beginPath();
                    tempCtx.ellipse(island.x, island.y - island.h * 0.3, island.w / 2.2, island.h / 4, 0, 0, Math.PI * 2);
                    tempCtx.fill();

                    // Highlight
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    tempCtx.beginPath();
                    tempCtx.ellipse(island.x - island.w * 0.1, island.y - island.h * 0.1, island.w / 3, island.h / 3, 0, 0, Math.PI * 2);
                    tempCtx.fill();
                });

                const dataUrl = tempCanvas.toDataURL();
                const img = await loadImage(dataUrl);
                exampleLayers.push({
                    id: Date.now() + 2,
                    name: 'Floating Islands',
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: layerWidth,
                    height: layerHeight,
                    depth: 0.6,
                    scale: 1,
                    rotation: 0
                });
            }

            // Layer 4: Foreground - Geometric Crystals
            {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = layerWidth;
                tempCanvas.height = layerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw crystal shapes
                const crystals = [
                    { x: 150, y: 700, size: 80, color: '#667eea' },
                    { x: 400, y: 650, size: 120, color: '#764ba2' },
                    { x: 950, y: 720, size: 100, color: '#f093fb' },
                    { x: 1400, y: 680, size: 90, color: '#4facfe' },
                    { x: 1700, y: 750, size: 70, color: '#00f2fe' }
                ];

                crystals.forEach(crystal => {
                    // Crystal facets
                    tempCtx.save();
                    tempCtx.translate(crystal.x, crystal.y);
                    
                    // Main crystal shape
                    tempCtx.fillStyle = crystal.color;
                    tempCtx.globalAlpha = 0.8;
                    tempCtx.beginPath();
                    tempCtx.moveTo(0, -crystal.size);
                    tempCtx.lineTo(crystal.size * 0.4, -crystal.size * 0.3);
                    tempCtx.lineTo(crystal.size * 0.5, crystal.size * 0.3);
                    tempCtx.lineTo(0, crystal.size * 0.5);
                    tempCtx.lineTo(-crystal.size * 0.5, crystal.size * 0.3);
                    tempCtx.lineTo(-crystal.size * 0.4, -crystal.size * 0.3);
                    tempCtx.closePath();
                    tempCtx.fill();

                    // Highlight facet
                    tempCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    tempCtx.beginPath();
                    tempCtx.moveTo(0, -crystal.size);
                    tempCtx.lineTo(crystal.size * 0.4, -crystal.size * 0.3);
                    tempCtx.lineTo(0, 0);
                    tempCtx.closePath();
                    tempCtx.fill();

                    // Shadow facet
                    tempCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    tempCtx.beginPath();
                    tempCtx.moveTo(0, 0);
                    tempCtx.lineTo(crystal.size * 0.5, crystal.size * 0.3);
                    tempCtx.lineTo(0, crystal.size * 0.5);
                    tempCtx.closePath();
                    tempCtx.fill();

                    tempCtx.restore();
                });

                const dataUrl = tempCanvas.toDataURL();
                const img = await loadImage(dataUrl);
                exampleLayers.push({
                    id: Date.now() + 3,
                    name: 'Crystal Foreground',
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: layerWidth,
                    height: layerHeight,
                    depth: 1,
                    scale: 1,
                    rotation: 0
                });
            }

            // Layer 5: Near Elements - Floating Particles
            {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = layerWidth;
                tempCanvas.height = layerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Floating light particles
                for (let i = 0; i < 40; i++) {
                    const x = Math.random() * layerWidth;
                    const y = Math.random() * layerHeight;
                    const size = Math.random() * 30 + 10;
                    const hue = Math.random() * 60 + 180; // Blue to cyan range
                    
                    // Glow
                    const gradient = tempCtx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `hsla(${hue}, 80%, 70%, 0.6)`);
                    gradient.addColorStop(0.5, `hsla(${hue}, 70%, 60%, 0.3)`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    tempCtx.fillStyle = gradient;
                    tempCtx.beginPath();
                    tempCtx.arc(x, y, size, 0, Math.PI * 2);
                    tempCtx.fill();

                    // Core
                    tempCtx.fillStyle = `hsla(${hue}, 90%, 80%, 0.9)`;
                    tempCtx.beginPath();
                    tempCtx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                    tempCtx.fill();
                }

                const dataUrl = tempCanvas.toDataURL();
                const img = await loadImage(dataUrl);
                exampleLayers.push({
                    id: Date.now() + 4,
                    name: 'Light Particles',
                    image: img,
                    dataUrl: dataUrl,
                    visible: true,
                    opacity: 1,
                    left: 0,
                    top: 0,
                    width: layerWidth,
                    height: layerHeight,
                    depth: 1.5,
                    scale: 1,
                    rotation: 0
                });
            }

            layers = exampleLayers;

            updateCanvas();
            updateLayersList();
            hideLoading();

            // Set example caption
            document.getElementById('captionEnabled').checked = true;
            document.getElementById('captionText').value = 'Caption goes here, Parallax depth creates immersive scroll storytelling';
            document.getElementById('captionCredit').value = 'Caption credit';
        }

        function render() {
            const scrollTop = previewWrapper.scrollTop;
            const scrollProgress = Math.min(scrollTop / config.scrollDuration, 1);
            
            config.bgColor = document.getElementById('bgColor').value;
            config.imageFit = document.getElementById('imageFit').value;
            
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            let globalScale = 1;
            let globalBlur = 0;
            let globalAlpha = 1;
            let globalOffsetY = 0;

            switch (globalEffect) {
                case 'zoom':
                    // Zoom within container - scale from 1.5x to 1x (zooming in from cropped state)
                    globalScale = 1.5 - (scrollProgress * 0.5 * effectIntensity);
                    break;
                case 'zoom-out':
                    // Zoom out from 1x to smaller
                    globalScale = 1 + scrollProgress * effectIntensity;
                    break;
                case 'blur-reveal':
                    // Ends at 50% scroll - very fast resolve
                    const blurProgress = Math.max(0, 1 - (scrollProgress * 2));
                    globalBlur = blurProgress * blurProgress * 30 * effectIntensity;
                    break;
                case 'fade-in':
                    // This wasn't working - now it will
                    globalAlpha = scrollProgress;
                    break;
                case 'slide-up':
                    // Will be handled per-layer below
                    break;
            }

            if (globalBlur > 0) {
                ctx.filter = `blur(${globalBlur}px)`;
            }

            ctx.save();

            layers.forEach((layer, index) => {
                if (!layer.visible || !layer.image) return;

                ctx.save();
                
                // Apply per-layer scroll speed multiplier
                const layerScrollSpeed = layer.scrollSpeed || 1;
                const adjustedScrollProgress = Math.min(scrollProgress * layerScrollSpeed, 1);

                let layerAlpha = layer.opacity * globalAlpha;
                let offsetX = 0;
                let offsetY = globalOffsetY;
                let scale = globalScale;

                if (globalEffect === 'parallax') {
                    const depthOffset = (adjustedScrollProgress - 0.5) * canvas.height * 0.3 * layer.depth * effectIntensity;
                    offsetY += depthOffset;
                    scale *= 1 - (layer.depth * 0.1 * effectIntensity);
                } else if (globalEffect === 'cascade') {
                    // Each layer appears progressively
                    const layerProgress = Math.max(0, Math.min(1, adjustedScrollProgress * layers.length - index));
                    layerAlpha = layer.opacity * layerProgress;
                } else if (globalEffect === 'slide-up') {
                    // One layer at a time, bottom to top (reverse index order)
                    const reverseIndex = layers.length - 1 - index;
                    const layerStartProgress = reverseIndex / layers.length;
                    const layerDuration = 0.25; // Each layer takes 25% of scroll
                    const layerProgress = Math.max(0, Math.min(1, (adjustedScrollProgress - layerStartProgress) / layerDuration));
                    offsetY = (1 - layerProgress) * canvas.height * 1.5;
                    layerAlpha = layer.opacity * Math.min(layerProgress * 3, 1); // Quick fade
                }

                ctx.globalAlpha = layerAlpha;

                // Apply image fit
                let drawWidth = layer.width;
                let drawHeight = layer.height;
                let drawX = layer.left;
                let drawY = layer.top;

                if (config.imageFit === 'cover' || config.imageFit === 'contain') {
                    const layerAspect = layer.width / layer.height;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    if (config.imageFit === 'cover') {
                        if (layerAspect > canvasAspect) {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * layerAspect;
                        } else {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / layerAspect;
                        }
                    } else { // contain
                        if (layerAspect > canvasAspect) {
                            drawWidth = canvas.width;
                            drawHeight = drawWidth / layerAspect;
                        } else {
                            drawHeight = canvas.height;
                            drawWidth = drawHeight * layerAspect;
                        }
                    }
                    
                    drawX = (canvas.width - drawWidth) / 2;
                    drawY = (canvas.height - drawHeight) / 2;
                } else if (config.imageFit === 'fill') {
                    drawWidth = canvas.width;
                    drawHeight = canvas.height;
                    drawX = 0;
                    drawY = 0;
                }

                // Add overscan for effects to prevent edge exposure
                if (globalEffect === 'parallax') {
                    // Calculate maximum offset this layer will experience
                    const maxOffset = canvas.height * 0.3 * layer.depth * effectIntensity * 0.5;
                    // Scale up the layer to cover edges during movement
                    const overscanFactor = 1 + (maxOffset * 2.5 / Math.min(drawWidth, drawHeight));
                    const originalDrawWidth = drawWidth;
                    const originalDrawHeight = drawHeight;
                    drawWidth *= overscanFactor;
                    drawHeight *= overscanFactor;
                    // Recenter after scaling
                    drawX -= (drawWidth - originalDrawWidth) / 2;
                    drawY -= (drawHeight - originalDrawHeight) / 2;
                } else if (globalEffect === 'zoom') {
                    // For zoom effect, make layers larger so zoom stays within container
                    const zoomOverscan = 1.5;
                    const originalDrawWidth = drawWidth;
                    const originalDrawHeight = drawHeight;
                    drawWidth *= zoomOverscan;
                    drawHeight *= zoomOverscan;
                    drawX -= (drawWidth - originalDrawWidth) / 2;
                    drawY -= (drawHeight - originalDrawHeight) / 2;
                } else if (globalEffect === 'slide-up') {
                    // Add overscan for vertical movement
                    const slideOverscan = 1.3;
                    const originalDrawHeight = drawHeight;
                    drawHeight *= slideOverscan;
                    drawY -= (drawHeight - originalDrawHeight) / 2;
                }

                const x = drawX + offsetX;
                const y = drawY + offsetY;

                ctx.translate(x + drawWidth / 2, y + drawHeight / 2);
                ctx.scale(scale, scale);
                ctx.rotate(layer.rotation);
                ctx.drawImage(layer.image, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);

                ctx.restore();
            });

            ctx.restore();
            ctx.filter = 'none';

            updateCaption(scrollProgress);
        }

        function updateCaption(scrollProgress) {
            config.captionEnabled = document.getElementById('captionEnabled').checked;
            config.captionText = document.getElementById('captionText').value;
            config.captionCredit = document.getElementById('captionCredit').value;
            config.captionStart = parseInt(document.getElementById('captionStart').value) / 100;
            config.captionEnd = parseInt(document.getElementById('captionEnd').value) / 100;

            const captionOverlay = document.getElementById('captionOverlay');
            const captionTextDisplay = document.getElementById('captionTextDisplay');
            const captionCreditDisplay = document.getElementById('captionCreditDisplay');

            if (config.captionEnabled && config.captionText && 
                scrollProgress >= config.captionStart && scrollProgress <= config.captionEnd) {
                captionTextDisplay.textContent = config.captionText;
                captionCreditDisplay.textContent = config.captionCredit;
                captionOverlay.classList.add('visible');
            } else {
                captionOverlay.classList.remove('visible');
            }
        }

        previewWrapper.addEventListener('scroll', render);
        window.addEventListener('resize', updateCanvas);

        function generateEmbedCode() {
            if (layers.length === 0) {
                alert('Add some layers first!');
                return;
            }

            showLoading('Generating HTML...');

            setTimeout(() => {
                const layersData = layers.map(l => ({
                    name: l.name,
                    dataUrl: l.dataUrl,
                    visible: l.visible,
                    opacity: l.opacity,
                    left: l.left,
                    top: l.top,
                    width: l.width,
                    height: l.height,
                    depth: l.depth,
                    scale: l.scale,
                    rotation: l.rotation
                }));

                const code = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Scrolltastic Story</title><style>*{margin:0;padding:0;box-sizing:border-box}body{background:${config.bgColor};overflow-x:hidden}.scroll-container{position:relative;height:${config.scrollDuration}px}.viewport-container{position:sticky;top:0;width:100%;height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden}.viewport-wrapper{position:relative;display:flex;flex-direction:column;align-items:center;width:98%}.viewport{position:relative;width:100%;overflow:hidden;display:flex;align-items:center;justify-content:center;aspect-ratio:${config.width}/${config.height}}canvas{display:block;width:100%;height:100%;object-fit:contain}.caption{position:relative;width:85%;max-width:700px;padding:10px 16px;background:rgba(0,0,0,.9);font-size:13px;line-height:1.5;opacity:0;transition:opacity .5s;color:#e0e0e0;z-index:20}.caption.visible{opacity:1}.caption-credit{color:#999;font-size:11px;font-style:italic;margin-top:4px}</style></head><body><div class="scroll-container"><div class="viewport-container"><div class="viewport-wrapper"><div class="viewport"><canvas id="canvas"></canvas></div><div class="caption" id="caption"><div id="captionText"></div><div class="caption-credit" id="captionCredit"></div></div></div></div></div><script>const canvas=document.getElementById('canvas'),ctx=canvas.getContext('2d');canvas.width=${config.width};canvas.height=${config.height};const config=${JSON.stringify({width:config.width,height:config.height,bgColor:config.bgColor,imageFit:config.imageFit,scrollDuration:config.scrollDuration,captionEnabled:config.captionEnabled,captionText:config.captionText,captionCredit:config.captionCredit,captionStart:config.captionStart,captionEnd:config.captionEnd})};const layersData=${JSON.stringify(layersData)};const layers=[];const globalEffect='${globalEffect}';const effectIntensity=${effectIntensity};let loadedCount=0;layersData.forEach(l=>{const img=new Image();img.onload=()=>{loadedCount++;if(loadedCount===layersData.length)render()};img.src=l.dataUrl;layers.push({...l,image:img})});function render(){const scrollProgress=Math.min(window.pageYOffset/config.scrollDuration,1);ctx.fillStyle=config.bgColor;ctx.fillRect(0,0,canvas.width,canvas.height);let globalScale=1,globalBlur=0,globalAlpha=1,globalOffsetY=0;switch(globalEffect){case 'zoom':globalScale=1.5-scrollProgress*.5*effectIntensity;break;case 'zoom-out':globalScale=1+scrollProgress*effectIntensity;break;case 'blur-reveal':const blurProgress=1-scrollProgress*scrollProgress;globalBlur=blurProgress*30*effectIntensity;break;case 'fade-in':globalAlpha=scrollProgress;break;case 'slide-up':globalOffsetY=(1-scrollProgress)*canvas.height*1.2;globalAlpha=Math.min(scrollProgress*2,1);break}if(globalBlur>0)ctx.filter=\`blur(\${globalBlur}px)\`;ctx.save();layers.forEach((layer,index)=>{if(!layer.visible||!layer.image)return;ctx.save();let layerAlpha=layer.opacity*globalAlpha,offsetX=0,offsetY=globalOffsetY,scale=globalScale;if(globalEffect==='parallax'){const depthOffset=(scrollProgress-.5)*canvas.height*.3*layer.depth*effectIntensity;offsetY+=depthOffset;scale*=1-layer.depth*.1*effectIntensity}else if(globalEffect==='cascade'){const layerProgress=Math.max(0,Math.min(1,scrollProgress*layers.length-index));layerAlpha=layer.opacity*layerProgress}else if(globalEffect==='slide-up'){const layerDelay=index/layers.length*.3;const layerProgress=Math.max(0,Math.min(1,(scrollProgress-layerDelay)/.7));offsetY=(1-layerProgress)*canvas.height*1.2;layerAlpha=layer.opacity*Math.min(layerProgress*2,1)}ctx.globalAlpha=layerAlpha;let drawWidth=layer.width,drawHeight=layer.height,drawX=layer.left,drawY=layer.top;if(config.imageFit==='cover'||config.imageFit==='contain'){const layerAspect=layer.width/layer.height,canvasAspect=canvas.width/canvas.height;if(config.imageFit==='cover'){if(layerAspect>canvasAspect){drawHeight=canvas.height;drawWidth=drawHeight*layerAspect}else{drawWidth=canvas.width;drawHeight=drawWidth/layerAspect}}else{if(layerAspect>canvasAspect){drawWidth=canvas.width;drawHeight=drawWidth/layerAspect}else{drawHeight=canvas.height;drawWidth=drawHeight*layerAspect}}drawX=(canvas.width-drawWidth)/2;drawY=(canvas.height-drawHeight)/2}else if(config.imageFit==='fill'){drawWidth=canvas.width;drawHeight=canvas.height;drawX=0;drawY=0}if(globalEffect==='parallax'){const maxOffset=canvas.height*.3*layer.depth*effectIntensity*.5;const overscanFactor=1+maxOffset*2.5/Math.min(drawWidth,drawHeight);const originalDrawWidth=drawWidth,originalDrawHeight=drawHeight;drawWidth*=overscanFactor;drawHeight*=overscanFactor;drawX-=(drawWidth-originalDrawWidth)/2;drawY-=(drawHeight-originalDrawHeight)/2}else if(globalEffect==='zoom'){const zoomOverscan=1.5;const originalDrawWidth=drawWidth,originalDrawHeight=drawHeight;drawWidth*=zoomOverscan;drawHeight*=zoomOverscan;drawX-=(drawWidth-originalDrawWidth)/2;drawY-=(drawHeight-originalDrawHeight)/2}else if(globalEffect==='slide-up'){const slideOverscan=1.3;const originalDrawHeight=drawHeight;drawHeight*=slideOverscan;drawY-=(drawHeight-originalDrawHeight)/2}const x=drawX+offsetX,y=drawY+offsetY;ctx.translate(x+drawWidth/2,y+drawHeight/2);ctx.scale(scale,scale);ctx.rotate(layer.rotation);ctx.drawImage(layer.image,-drawWidth/2,-drawHeight/2,drawWidth,drawHeight);ctx.restore()});ctx.restore();ctx.filter='none';const caption=document.getElementById('caption'),captionText=document.getElementById('captionText'),captionCredit=document.getElementById('captionCredit');if(config.captionEnabled&&config.captionText&&scrollProgress>=config.captionStart&&scrollProgress<=config.captionEnd){captionText.textContent=config.captionText;captionCredit.textContent=config.captionCredit;caption.classList.add('visible')}else{caption.classList.remove('visible')}}let raf;window.addEventListener('scroll',()=>{if(!raf)raf=requestAnimationFrame(()=>{render();raf=null})})<\/script></body></html>`;

                document.getElementById('embedCode').value = code;
                hideLoading();
            }, 100);
        }

        function copyCode() {
            const textarea = document.getElementById('embedCode');
            if (!textarea.value) {
                alert('Generate HTML first!');
                return;
            }
            textarea.select();
            document.execCommand('copy');
            alert('Code copied!');
        }

        function downloadHTML() {
            const code = document.getElementById('embedCode').value;
            if (!code) {
                alert('Generate HTML first!');
                return;
            }
            const blob = new Blob([code], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'scrolltastic-story.html';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function saveProject() {
            const project = {
                version: 4,
                config: config,
                globalEffect: globalEffect,
                effectIntensity: effectIntensity,
                layers: layers.map(l => {
                    const copy = { ...l };
                    delete copy.image;
                    return copy;
                })
            };
            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'scrolltastic-project.json';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        async function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                showLoading('Loading project...');
                try {
                    const text = await file.text();
                    const project = JSON.parse(text);
                    config = project.config;
                    globalEffect = project.globalEffect || 'parallax';
                    effectIntensity = project.effectIntensity || 1;
                    
                    document.getElementById('aspectRatio').value = config.aspectRatio || 'auto';
                    document.getElementById('canvasWidth').value = config.width;
                    document.getElementById('canvasHeight').value = config.height;
                    document.getElementById('bgColor').value = config.bgColor;
                    document.getElementById('imageFit').value = config.imageFit;
                    document.getElementById('scrollDuration').value = config.scrollDuration;
                    document.getElementById('scrollValue').textContent = config.scrollDuration;
                    document.getElementById('effectIntensity').value = effectIntensity;
                    document.getElementById('intensityValue').textContent = effectIntensity.toFixed(1);
                    document.getElementById('captionEnabled').checked = config.captionEnabled;
                    document.getElementById('captionText').value = config.captionText || '';
                    document.getElementById('captionCredit').value = config.captionCredit || '';
                    document.getElementById('captionStart').value = (config.captionStart * 100) || 20;
                    document.getElementById('captionEnd').value = (config.captionEnd * 100) || 60;
                    
                    layers = project.layers;
                    for (const layer of layers) {
                        layer.image = await loadImage(layer.dataUrl);
                    }
                    
                    updateCanvas();
                    updateLayersList();
                    hideLoading();
                } catch (error) {
                    alert('Error: ' + error.message);
                    hideLoading();
                }
            };
            input.click();
        }

        updateCanvas();
        updateLayersList(); // Initialize button states on page load
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Hotspots</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            align-items: start;
            transition: grid-template-columns 0.3s ease;
        }

        .container.controls-hidden {
            grid-template-columns: 0 1fr;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .controls.hidden {
            opacity: 0;
            transform: translateX(-20px);
            pointer-events: none;
        }

        .toggle-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 10px 16px;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            color: #e0e0e0;
            transition: background 0.2s;
        }

        .toggle-controls:hover {
            background: #2a2a2a;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
            color: #fff;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #fff;
            border-bottom: 1px solid #2a2a2a;
            padding-bottom: 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h2:hover {
            color: #4a9eff;
        }

        h2::after {
            content: '‚ñº';
            font-size: 12px;
            transition: transform 0.2s;
        }

        h2.collapsed::after {
            transform: rotate(-90deg);
        }

        .section-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .section-content.collapsed {
            max-height: 0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 2px dashed #444;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
        }

        input[type="file"]:hover {
            border-color: #666;
            background: #333;
        }

        input[type="number"],
        input[type="text"],
        input[type="url"],
        input[type="color"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
        }

        textarea#embedCode {
            min-height: 300px;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #888;
            font-size: 13px;
        }

        .split-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            transform: scale(0.98);
        }

        button.add-btn {
            background: #34a853;
        }

        button.add-btn:hover {
            background: #2d8e47;
        }

        button.remove-btn {
            background: #ff4444;
            padding: 5px 10px;
            font-size: 12px;
            width: auto;
        }

        button.remove-btn:hover {
            background: #cc0000;
        }

        button.secondary {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        button.secondary:hover {
            background: #3a3a3a;
        }

        .copy-btn {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        .copy-btn:hover {
            background: #3a3a3a;
        }

        .preview-container {
            position: relative;
        }

        .preview-wrapper {
            background: #0a0a0a;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #2a2a2a;
            height: 600px;
            overflow-y: scroll;
            scroll-behavior: smooth;
        }

        .preview-scroll-content {
            position: relative;
        }

        .preview-canvas-wrapper {
            position: sticky;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        #previewCanvas {
            display: block;
            max-width: 100%;
            cursor: crosshair;
        }

        .caption-text {
            position: relative;
            width: 85%;
            max-width: 700px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.9);
            color: #e0e0e0;
            font-size: 13px;
            line-height: 1.5;
            margin: 0 auto;
            display: none;
        }

        .caption-text.visible {
            display: block;
        }

        .caption-credit {
            color: #999;
            font-size: 11px;
            font-style: italic;
            margin-top: 4px;
        }

        .scroll-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #444;
            text-align: center;
            font-size: 14px;
            pointer-events: none;
        }

        .hotspot-item {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .hotspot-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            cursor: pointer;
            user-select: none;
        }

        .hotspot-item-header h3 {
            font-size: 14px;
            color: #4a9eff;
            margin: 0;
            flex: 1;
        }

        .hotspot-item-header::before {
            content: '‚ñº';
            font-size: 12px;
            margin-right: 8px;
            transition: transform 0.2s;
            color: #888;
        }

        .hotspot-item-header.collapsed::before {
            transform: rotate(-90deg);
        }

        .hotspot-controls {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .hotspot-controls.collapsed {
            max-height: 0;
        }

        .file-info {
            font-size: 11px;
            color: #666;
            margin-top: 6px;
        }

        .code-section {
            margin-top: 20px;
        }

        .setting-mode {
            background: #34a853;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
            margin-bottom: 12px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                position: relative;
                top: 0;
            }

            .toggle-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="toggle-controls" onclick="toggleControls()">‚ò∞ Controls</div>

    <div class="container" id="container">
        <div class="panel controls" id="controls">
            <h1>Scrolltastic Hotspots</h1>
            
            <h2 onclick="toggleSection(this)">Image Source</h2>
            <div class="section-content">
                <div class="control-group">
                    <label>Load Method</label>
                    <select id="loadMethod" onchange="toggleLoadMethod()">
                        <option value="upload">Upload from Local</option>
                        <option value="url">Direct Image URL</option>
                    </select>
                </div>

                <div class="control-group" id="uploadSection">
                    <label>Upload Image</label>
                    <input type="file" id="imageInput" accept="image/*">
                    <div class="file-info" id="fileInfo">No image selected</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                        <button onclick="loadExampleHotspots()" style="background: #9b59b6;">Load Example</button>
                        <button onclick="clearAllHotspots()" style="background: #e74c3c;">Clear All</button>
                    </div>
                </div>

                <div class="control-group" id="urlSection" style="display: none;">
                    <label>Direct Image URL</label>
                    <input type="url" id="imageUrl" placeholder="https://example.com/image.jpg">
                    <button onclick="loadFromURL()" style="margin-top: 10px;">Load Image</button>
                </div>

                <div class="control-group">
                    <label>Aspect Ratio Presets</label>
                    <select id="aspectRatio" onchange="applyAspectRatio()">
                        <option value="custom">Custom</option>
                        <option value="9:16">Vertical Phone (9:16)</option>
                        <option value="16:9" selected>Widescreen (16:9)</option>
                        <option value="4:3">Desktop Standard (4:3)</option>
                        <option value="16:10">Desktop Wide (16:10)</option>
                        <option value="21:9">Ultrawide (21:9)</option>
                        <option value="1:1">Square (1:1)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Dimensions</label>
                    <div class="split-inputs">
                        <input type="number" id="widthInput" placeholder="Width" value="1920">
                        <input type="number" id="heightInput" placeholder="Height" value="1080">
                    </div>
                    <div class="file-info" id="dimensionsInfo">1920 x 1080 (16:9 ratio)</div>
                </div>

                <div class="control-group">
                    <label>Image Fit</label>
                    <select id="imageFit" onchange="updatePreview(); generateEmbedCode();">
                        <option value="contain" selected>Contain (fit whole image)</option>
                        <option value="cover">Cover (fill viewport)</option>
                        <option value="fill">Fill (stretch to fit)</option>
                        <option value="none">None (actual size)</option>
                    </select>
                    <div class="file-info">How the image fills the canvas</div>
                </div>

                <div class="control-group">
                    <label>Scroll Duration (pixels)</label>
                    <div class="split-inputs">
                        <input type="number" id="scrollDurationNumber" min="500" max="5000" step="100" value="2000" 
                               oninput="document.getElementById('scrollDuration').value = this.value; document.getElementById('scrollValue').textContent = this.value; updatePreview(); generateEmbedCode();">
                        <input type="range" id="scrollDuration" min="500" max="5000" step="100" value="2000"
                               oninput="document.getElementById('scrollDurationNumber').value = this.value; document.getElementById('scrollValue').textContent = this.value; updatePreview(); generateEmbedCode();">
                    </div>
                    <div class="file-info">Current: <span id="scrollValue">2000</span>px</div>
                </div>

                <div class="control-group">
                    <label>Caption Font Family</label>
                    <select id="captionFontFamily" onchange="updatePreview(); generateEmbedCode();">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" selected>System Font</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="captionEnabled" checked onchange="toggleCaption(this.checked)" style="width: auto; margin-right: 8px;">
                        Enable Caption Display
                    </label>
                    <div class="file-info">Auto-extracted from image metadata when available</div>
                </div>
            </div>

            <h2 onclick="toggleSection(this)">Hotspots</h2>
            <div class="section-content">
                <div id="settingMode" style="display: none;" class="setting-mode">
                    Click on image to set position
                </div>
                <button class="add-btn" onclick="addHotspot()" style="margin-bottom: 15px;">+ Add Hotspot</button>
                <div id="hotspotsList"></div>
            </div>

            <h2 onclick="toggleSection(this)">Custom Fonts</h2>
            <div class="section-content">
                <div class="control-group">
                    <label>Google Fonts URL or Font Name</label>
                    <input type="text" id="customFontInput" placeholder="e.g., Playfair Display or https://fonts.googleapis.com/css2?family=...">
                    <button onclick="addCustomFont()" style="margin-top: 10px;">Add Font</button>
                </div>
                <div id="customFontsList"></div>
            </div>

            <div class="code-section">
                <h2 onclick="toggleSection(this)">Embed Code</h2>
                <div class="section-content">
                    <textarea id="embedCode" readonly></textarea>
                    <button class="copy-btn" onclick="copyCode()" style="margin-top: 10px;">Copy to Clipboard</button>
                    <button class="copy-btn" onclick="downloadCode()" style="background: #34a853; margin-top: 10px;">Download HTML File</button>
                </div>
            </div>

            <button onclick="saveProject()" style="margin-top: 20px; background: #9b59b6;">Save Project (.json)</button>
            <button onclick="loadProject()" style="margin-top: 10px; background: #9b59b6;">Load Project</button>
        </div>

        <div class="panel preview-container">
            <h2>Preview</h2>
            <div class="preview-wrapper" id="previewWrapper">
                <div class="preview-scroll-content" id="scrollContent">
                    <div class="preview-canvas-wrapper">
                        <canvas id="previewCanvas"></canvas>
                        <div class="caption-text" id="captionText"></div>
                    </div>
                    <div class="scroll-indicator" id="scrollIndicator">
                        Upload an image to add hotspots
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let sourceImage = null;
        let imageDataUrl = null;
        let hotspots = [];
        let customFonts = [];
        let hotspotIdCounter = 0;
        let settingHotspotId = null;
        let captionEnabled = true;
        let autoCaption = 'no caption info';

        // Load example hotspots
        function loadExampleHotspots() {
            const exampleURL = 'https://discophooey.github.io/my_personal_digital_team/examples/PLACE_HOLDER.png';
            
            const img = new Image();
            img.onload = () => {
                sourceImage = img;
                imageDataUrl = exampleURL;
                
                // Set dimensions to match example
                document.getElementById('widthInput').value = 1920;
                document.getElementById('heightInput').value = 1440;
                document.getElementById('aspectRatio').value = '4:3';
                
                // Add example hotspot
                hotspots = [{
                    id: ++hotspotIdCounter,
                    x: 50,
                    y: 50,
                    text: 'Example Hotspot - Click to edit'
                }];
                
                updatePreview();
                renderHotspotsList();
                document.getElementById('fileInfo').textContent = '‚úì Example image loaded';
                alert('‚úì Loaded example with hotspot');
            };
            img.onerror = () => {
                alert('Failed to load example image');
            };
            img.src = exampleURL;
        }

        // Clear all hotspots
        function clearAllHotspots() {
            if (!sourceImage && hotspots.length === 0) return;
            
            if (confirm('Clear image and all hotspots?')) {
                sourceImage = null;
                imageDataUrl = null;
                hotspots = [];
                hotspotIdCounter = 0;
                updatePreview();
                renderHotspotsList();
                document.getElementById('fileInfo').textContent = 'No image selected';
                document.getElementById('imageInput').value = '';
            }
        }

        const canvas = document.getElementById('previewCanvas');
        const ctx = canvas.getContext('2d');
        const previewWrapper = document.getElementById('previewWrapper');
        const scrollContent = document.getElementById('scrollContent');

        const aspectRatioPresets = {
            '9:16': { width: 1080, height: 1920, name: 'Vertical Phone' },
            '16:9': { width: 1920, height: 1080, name: 'Widescreen' },
            '4:3': { width: 1024, height: 768, name: 'Desktop Standard' },
            '16:10': { width: 1920, height: 1200, name: 'Desktop Wide' },
            '21:9': { width: 2560, height: 1080, name: 'Ultrawide' },
            '1:1': { width: 1080, height: 1080, name: 'Square' }
        };

        applyAspectRatio();
        updateDimensionsInfo();

        document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        document.getElementById('widthInput').addEventListener('input', updateDimensionsInfo);
        document.getElementById('heightInput').addEventListener('input', updateDimensionsInfo);

        previewWrapper.addEventListener('scroll', renderPreview);
        canvas.addEventListener('click', handleCanvasClick);

        function toggleControls() {
            const container = document.getElementById('container');
            const controls = document.getElementById('controls');
            container.classList.toggle('controls-hidden');
            controls.classList.toggle('hidden');
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }

        function toggleHotspot(id) {
            const header = document.querySelector(`#hotspot-header-${id}`);
            const controls = document.querySelector(`#hotspot-controls-${id}`);
            header.classList.toggle('collapsed');
            controls.classList.toggle('collapsed');
        }

        function toggleLoadMethod() {
            const method = document.getElementById('loadMethod').value;
            const uploadSection = document.getElementById('uploadSection');
            const urlSection = document.getElementById('urlSection');
            
            if (method === 'upload') {
                uploadSection.style.display = 'block';
                urlSection.style.display = 'none';
            } else {
                uploadSection.style.display = 'none';
                urlSection.style.display = 'block';
            }
        }

        function applyAspectRatio() {
            const selected = document.getElementById('aspectRatio').value;
            if (selected === 'custom') return;
            
            const preset = aspectRatioPresets[selected];
            if (preset) {
                document.getElementById('widthInput').value = preset.width;
                document.getElementById('heightInput').value = preset.height;
                updateDimensionsInfo();
            }
        }

        function updateDimensionsInfo() {
            const width = parseInt(document.getElementById('widthInput').value) || 1920;
            const height = parseInt(document.getElementById('heightInput').value) || 1080;
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(width, height);
            const ratio = `${width / divisor}:${height / divisor}`;
            document.getElementById('dimensionsInfo').textContent = `${width} x ${height} (${ratio} ratio)`;
            updatePreview();
        }

        function toggleCaption(enabled) {
            captionEnabled = enabled;
            updatePreview();
            generateEmbedCode();
        }

        function extractImageMetadata(file) {
            // Try to extract EXIF/IPTC metadata from image
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const view = new DataView(arrayBuffer);
                    
                    try {
                        // Look for JPEG markers
                        if (view.getUint16(0, false) === 0xFFD8) {
                            let offset = 2;
                            while (offset < view.byteLength) {
                                const marker = view.getUint16(offset, false);
                                offset += 2;
                                
                                if (marker === 0xFFE1) { // APP1 (EXIF)
                                    const length = view.getUint16(offset, false);
                                    const exifData = new Uint8Array(arrayBuffer, offset + 2, length - 2);
                                    const exifString = new TextDecoder('utf-8').decode(exifData);
                                    
                                    // Look for ImageDescription or UserComment
                                    if (exifString.includes('ImageDescription') || exifString.includes('UserComment')) {
                                        // Try to extract caption text (simplified)
                                        const match = exifString.match(/[\x20-\x7E]{10,}/g);
                                        if (match && match.length > 0) {
                                            const caption = match.find(m => m.length > 15 && !m.includes('Exif'));
                                            if (caption) {
                                                resolve(caption.substring(0, 200));
                                                return;
                                            }
                                        }
                                    }
                                    break;
                                }
                                
                                if (marker >= 0xFFE0 && marker <= 0xFFEF) {
                                    const length = view.getUint16(offset, false);
                                    offset += length;
                                } else {
                                    break;
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Could not extract metadata:', err);
                    }
                    
                    resolve('no caption info');
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Extract metadata first
            extractImageMetadata(file).then(caption => {
                autoCaption = caption;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadImageFromDataUrl(event.target.result);
                    imageDataUrl = event.target.result;
                    document.getElementById('fileInfo').textContent = file.name;
                    
                    // Set caption for first hotspot if it doesn't have one
                    if (hotspots.length > 0 && !hotspots[0].caption) {
                        hotspots[0].caption = autoCaption;
                        updateHotspotsList();
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        function loadFromURL() {
            const url = document.getElementById('imageUrl').value.trim();
            if (!url) {
                alert('Please enter an image URL');
                return;
            }

            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                sourceImage = img;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                imageDataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                
                document.getElementById('scrollIndicator').style.display = 'none';
                
                // Auto-update dimensions
                const imgRatio = img.width / img.height;
                let newWidth = 1920;
                let newHeight = Math.round(1920 / imgRatio);
                
                if (imgRatio < 1) {
                    newHeight = 1920;
                    newWidth = Math.round(1920 * imgRatio);
                }
                
                document.getElementById('widthInput').value = newWidth;
                document.getElementById('heightInput').value = newHeight;
                document.getElementById('aspectRatio').value = 'custom';
                
                updateDimensionsInfo();
                updatePreview();
                generateEmbedCode();
            };
            img.onerror = () => {
                alert('Failed to load image. Make sure the URL is correct and CORS is enabled.');
            };
            img.src = url;
        }

        function loadImageFromDataUrl(dataUrl) {
            const img = new Image();
            img.onload = () => {
                sourceImage = img;
                document.getElementById('scrollIndicator').style.display = 'none';
                
                // Auto-update dimensions
                const imgRatio = img.width / img.height;
                let newWidth = 1920;
                let newHeight = Math.round(1920 / imgRatio);
                
                if (imgRatio < 1) {
                    newHeight = 1920;
                    newWidth = Math.round(1920 * imgRatio);
                }
                
                document.getElementById('widthInput').value = newWidth;
                document.getElementById('heightInput').value = newHeight;
                document.getElementById('aspectRatio').value = 'custom';
                
                updateDimensionsInfo();
                updatePreview();
                generateEmbedCode();
            };
            img.src = dataUrl;
        }

        function addHotspot() {
            // Get settings from last hotspot if exists
            const lastHotspot = hotspots.length > 0 ? hotspots[hotspots.length - 1] : null;
            
            const hotspot = {
                id: hotspotIdCounter++,
                x: lastHotspot ? lastHotspot.x : 50,
                y: lastHotspot ? lastHotspot.y + 10 : 50,
                label: 'Click to edit',
                description: '',
                caption: lastHotspot && lastHotspot.caption ? lastHotspot.caption : (hotspots.length === 0 ? autoCaption : ''),
                credit: lastHotspot ? lastHotspot.credit : '',
                startScroll: lastHotspot ? lastHotspot.startScroll : 0,
                endScroll: lastHotspot ? lastHotspot.endScroll : 100,
                fadeIn: lastHotspot ? lastHotspot.fadeIn : 10,
                fadeOut: lastHotspot ? lastHotspot.fadeOut : 10,
                markerColor: lastHotspot ? lastHotspot.markerColor : '#ff6b35',
                lineLength: lastHotspot ? lastHotspot.lineLength : 60,
                labelPosition: lastHotspot ? lastHotspot.labelPosition : 'right',
                textAlign: lastHotspot ? lastHotspot.textAlign : 'left',
                fontSize: lastHotspot ? lastHotspot.fontSize : 40,
                fontFamily: lastHotspot ? lastHotspot.fontFamily : 'Arial',
                textTransform: lastHotspot ? lastHotspot.textTransform : 'none',
                letterSpacing: lastHotspot ? lastHotspot.letterSpacing : 0,
                lineHeight: lastHotspot ? lastHotspot.lineHeight : 1.2,
                shadowBlur: lastHotspot ? lastHotspot.shadowBlur : 0,
                shadowColor: lastHotspot ? lastHotspot.shadowColor : '#000000',
                clickAction: lastHotspot ? lastHotspot.clickAction : 'none',
                clickUrl: lastHotspot ? lastHotspot.clickUrl : '',
                clickScrollTo: lastHotspot ? lastHotspot.clickScrollTo : 0
            };
            hotspots.push(hotspot);
            updateHotspotsList();
            updatePreview();
            generateEmbedCode();
        }

        function removeHotspot(id) {
            hotspots = hotspots.filter(h => h.id !== id);
            updateHotspotsList();
            updatePreview();
            generateEmbedCode();
        }

        function updateHotspot(id, property, value) {
            const hotspot = hotspots.find(h => h.id === id);
            if (hotspot) {
                if (['x', 'y', 'startScroll', 'endScroll', 'fadeIn', 'fadeOut', 'fontSize', 'clickScrollTo', 
                     'lineLength', 'letterSpacing', 'lineHeight', 'shadowBlur'].includes(property)) {
                    hotspot[property] = parseFloat(value);
                } else {
                    hotspot[property] = value;
                }
                updatePreview();
                generateEmbedCode();
            }
        }

        function setHotspotPosition(id) {
            settingHotspotId = id;
            document.getElementById('settingMode').style.display = 'block';
            canvas.style.cursor = 'crosshair';
        }

        function handleCanvasClick(e) {
            if (!settingHotspotId) return;

            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100;
            const y = ((e.clientY - rect.top) / rect.height) * 100;

            const hotspot = hotspots.find(h => h.id === settingHotspotId);
            if (hotspot) {
                hotspot.x = Math.round(x * 10) / 10;
                hotspot.y = Math.round(y * 10) / 10;
                updateHotspotsList();
                updatePreview();
                generateEmbedCode();
            }

            settingHotspotId = null;
            document.getElementById('settingMode').style.display = 'none';
            canvas.style.cursor = 'default';
        }

        function updateHotspotsList() {
            const list = document.getElementById('hotspotsList');
            const fontOptions = [
                'Arial', 'Helvetica', 'Georgia', 'Times New Roman', 'Courier New', 
                'Verdana', 'Impact', '-apple-system, BlinkMacSystemFont, \'Segoe UI\', sans-serif'
            ].concat(customFonts.map(f => f.name));

            list.innerHTML = hotspots.map(hotspot => `
                <div class="hotspot-item">
                    <div class="hotspot-item-header" id="hotspot-header-${hotspot.id}" onclick="toggleHotspot(${hotspot.id})">
                        <h3>Hotspot ${hotspot.id + 1}</h3>
                        <button class="remove-btn" onclick="event.stopPropagation(); removeHotspot(${hotspot.id})">Remove</button>
                    </div>
                    
                    <div class="hotspot-controls" id="hotspot-controls-${hotspot.id}">
                        <div class="control-group">
                            <label>Label</label>
                            <input type="text" value="${hotspot.label}" onchange="updateHotspot(${hotspot.id}, 'label', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Description (optional)</label>
                            <textarea onchange="updateHotspot(${hotspot.id}, 'description', this.value)">${hotspot.description}</textarea>
                        </div>
                        
                        <div class="control-group">
                            <label>Caption (appears below image)</label>
                            <textarea onchange="updateHotspot(${hotspot.id}, 'caption', this.value)">${hotspot.caption || ''}</textarea>
                        </div>
                        
                        <div class="control-group">
                            <label>Credit (appears below caption, smaller/italic)</label>
                            <input type="text" value="${hotspot.credit || ''}" onchange="updateHotspot(${hotspot.id}, 'credit', this.value)" placeholder="Photo by...">
                        </div>
                        
                        <div class="control-group">
                            <label>Position X <span class="range-value">${hotspot.x.toFixed(1)}%</span></label>
                            <input type="range" min="0" max="100" step="0.1" value="${hotspot.x}"
                                   oninput="this.previousElementSibling.querySelector('.range-value').textContent = parseFloat(this.value).toFixed(1) + '%'; updateHotspot(${hotspot.id}, 'x', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Position Y <span class="range-value">${hotspot.y.toFixed(1)}%</span></label>
                            <input type="range" min="0" max="100" step="0.1" value="${hotspot.y}"
                                   oninput="this.previousElementSibling.querySelector('.range-value').textContent = parseFloat(this.value).toFixed(1) + '%'; updateHotspot(${hotspot.id}, 'y', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <button class="secondary" onclick="setHotspotPosition(${hotspot.id})">Click Image to Set Position</button>
                        </div>
                        
                        <div class="control-group">
                            <label>Scroll Range (%)</label>
                            <div class="split-inputs">
                                <input type="number" min="0" max="100" value="${hotspot.startScroll}" 
                                       onchange="updateHotspot(${hotspot.id}, 'startScroll', this.value)" placeholder="Start">
                                <input type="number" min="0" max="100" value="${hotspot.endScroll}" 
                                       onchange="updateHotspot(${hotspot.id}, 'endScroll', this.value)" placeholder="End">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Fade In/Out (%)</label>
                            <div class="split-inputs">
                                <input type="number" min="0" max="50" value="${hotspot.fadeIn}" 
                                       onchange="updateHotspot(${hotspot.id}, 'fadeIn', this.value)" placeholder="Fade In">
                                <input type="number" min="0" max="50" value="${hotspot.fadeOut}" 
                                       onchange="updateHotspot(${hotspot.id}, 'fadeOut', this.value)" placeholder="Fade Out">
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Marker Color</label>
                            <input type="color" value="${hotspot.markerColor}" onchange="updateHotspot(${hotspot.id}, 'markerColor', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Line Length <span class="range-value">${hotspot.lineLength}px</span></label>
                            <input type="range" min="20" max="200" step="5" value="${hotspot.lineLength}"
                                   oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + 'px'; updateHotspot(${hotspot.id}, 'lineLength', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Label Position</label>
                            <select onchange="updateHotspot(${hotspot.id}, 'labelPosition', this.value)">
                                <option value="right" ${hotspot.labelPosition === 'right' ? 'selected' : ''}>Right</option>
                                <option value="left" ${hotspot.labelPosition === 'left' ? 'selected' : ''}>Left</option>
                                <option value="top" ${hotspot.labelPosition === 'top' ? 'selected' : ''}>Top</option>
                                <option value="bottom" ${hotspot.labelPosition === 'bottom' ? 'selected' : ''}>Bottom</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Text Alignment in Box</label>
                            <select onchange="updateHotspot(${hotspot.id}, 'textAlign', this.value)">
                                <option value="left" ${hotspot.textAlign === 'left' ? 'selected' : ''}>Left</option>
                                <option value="right" ${hotspot.textAlign === 'right' ? 'selected' : ''}>Right</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Font Size</label>
                            <input type="number" value="${hotspot.fontSize}" onchange="updateHotspot(${hotspot.id}, 'fontSize', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Font Family</label>
                            <select onchange="updateHotspot(${hotspot.id}, 'fontFamily', this.value)">
                                ${fontOptions.map(font => `<option value="${font}" ${hotspot.fontFamily === font ? 'selected' : ''}>${font.length > 40 ? 'System Font' : font}</option>`).join('')}
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Text Transform</label>
                            <select onchange="updateHotspot(${hotspot.id}, 'textTransform', this.value)">
                                <option value="none" ${hotspot.textTransform === 'none' ? 'selected' : ''}>None</option>
                                <option value="uppercase" ${hotspot.textTransform === 'uppercase' ? 'selected' : ''}>UPPERCASE</option>
                                <option value="lowercase" ${hotspot.textTransform === 'lowercase' ? 'selected' : ''}>lowercase</option>
                                <option value="capitalize" ${hotspot.textTransform === 'capitalize' ? 'selected' : ''}>Capitalize</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Letter Spacing (px)</label>
                            <input type="number" value="${hotspot.letterSpacing}" step="0.5" onchange="updateHotspot(${hotspot.id}, 'letterSpacing', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Line Height</label>
                            <input type="number" value="${hotspot.lineHeight}" step="0.1" min="0.5" max="3" onchange="updateHotspot(${hotspot.id}, 'lineHeight', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Shadow Blur (px)</label>
                            <input type="number" value="${hotspot.shadowBlur}" min="0" max="50" onchange="updateHotspot(${hotspot.id}, 'shadowBlur', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Shadow Color</label>
                            <input type="color" value="${hotspot.shadowColor}" onchange="updateHotspot(${hotspot.id}, 'shadowColor', this.value)">
                        </div>
                        
                        <div class="control-group">
                            <label>Click Action</label>
                            <select onchange="updateHotspot(${hotspot.id}, 'clickAction', this.value); updateHotspotsList();">
                                <option value="none" ${hotspot.clickAction === 'none' ? 'selected' : ''}>None</option>
                                <option value="url" ${hotspot.clickAction === 'url' ? 'selected' : ''}>Open URL</option>
                                <option value="scroll" ${hotspot.clickAction === 'scroll' ? 'selected' : ''}>Scroll To Position</option>
                            </select>
                        </div>
                        
                        ${hotspot.clickAction === 'url' ? `
                        <div class="control-group">
                            <label>URL</label>
                            <input type="url" value="${hotspot.clickUrl}" onchange="updateHotspot(${hotspot.id}, 'clickUrl', this.value)" placeholder="https://example.com">
                        </div>
                        ` : ''}
                        
                        ${hotspot.clickAction === 'scroll' ? `
                        <div class="control-group">
                            <label>Scroll To (%)</label>
                            <input type="number" min="0" max="100" value="${hotspot.clickScrollTo}" onchange="updateHotspot(${hotspot.id}, 'clickScrollTo', this.value)">
                        </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        function addCustomFont() {
            const input = document.getElementById('customFontInput').value.trim();
            if (!input) return;

            let fontName = input;
            let fontUrl = null;

            if (input.startsWith('http')) {
                const match = input.match(/family=([^:&]+)/);
                if (match) {
                    fontName = match[1].replace(/\+/g, ' ');
                    fontUrl = input;
                }
            }

            customFonts.push({ name: fontName, url: fontUrl });
            
            if (fontUrl) {
                const link = document.createElement('link');
                link.href = fontUrl;
                link.rel = 'stylesheet';
                document.head.appendChild(link);
            }

            updateCustomFontsList();
            updateHotspotsList();
            generateEmbedCode();
            document.getElementById('customFontInput').value = '';
        }

        function removeCustomFont(index) {
            customFonts.splice(index, 1);
            updateCustomFontsList();
            updateHotspotsList();
            generateEmbedCode();
        }

        function updateCustomFontsList() {
            const list = document.getElementById('customFontsList');
            if (customFonts.length === 0) {
                list.innerHTML = '';
                return;
            }
            list.innerHTML = customFonts.map((font, index) => `
                <div style="background: #2a2a2a; padding: 8px 12px; border-radius: 6px; margin-top: 8px; font-size: 12px; display: flex; justify-content: space-between; align-items: center;">
                    ${font.name}
                    <button class="remove-btn" onclick="removeCustomFont(${index})">Remove</button>
                </div>
            `).join('');
        }

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;
            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x;
                    drawY = y;
                    drawWidth = width;
                    drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width;
                    drawHeight = img.height;
                    break;
            }

            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        function updatePreview() {
            const width = parseInt(document.getElementById('widthInput').value) || 1920;
            const height = parseInt(document.getElementById('heightInput').value) || 1080;
            const scrollDuration = parseInt(document.getElementById('scrollDuration').value) || 2000;

            canvas.width = width;
            canvas.height = height;

            scrollContent.style.height = (height + scrollDuration) + 'px';

            renderPreview();
        }

        function renderPreview() {
            if (!sourceImage) return;

            const scrollTop = previewWrapper.scrollTop;
            const scrollDuration = parseInt(document.getElementById('scrollDuration').value) || 2000;
            const scrollProgress = Math.min(scrollTop / scrollDuration, 1);
            const imageFit = document.getElementById('imageFit').value;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawImageWithFit(ctx, sourceImage, 0, 0, canvas.width, canvas.height, imageFit);

            // Draw hotspots
            hotspots.forEach(hotspot => {
                const hotspotScrollStart = hotspot.startScroll / 100;
                const hotspotScrollEnd = hotspot.endScroll / 100;

                if (scrollProgress < hotspotScrollStart || scrollProgress > hotspotScrollEnd) return;

                const hotspotDuration = hotspotScrollEnd - hotspotScrollStart;
                const hotspotProgress = (scrollProgress - hotspotScrollStart) / hotspotDuration;

                let opacity = 1;
                if (hotspotProgress < hotspot.fadeIn / 100) {
                    opacity = hotspotProgress / (hotspot.fadeIn / 100);
                } else if (hotspotProgress > 1 - (hotspot.fadeOut / 100)) {
                    opacity = (1 - hotspotProgress) / (hotspot.fadeOut / 100);
                }

                const x = (hotspot.x / 100) * canvas.width;
                const y = (hotspot.y / 100) * canvas.height;

                ctx.save();
                ctx.globalAlpha = opacity;
                
                // Draw solid dot
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fillStyle = hotspot.markerColor;
                ctx.fill();

                // Draw label
                if (hotspot.label) {
                    // Apply text transform
                    let displayText = hotspot.label;
                    switch(hotspot.textTransform) {
                        case 'uppercase': displayText = displayText.toUpperCase(); break;
                        case 'lowercase': displayText = displayText.toLowerCase(); break;
                        case 'capitalize': displayText = displayText.replace(/\b\w/g, l => l.toUpperCase()); break;
                    }

                    ctx.font = `${hotspot.fontSize}px ${hotspot.fontFamily}`;
                    ctx.fillStyle = '#e0e0e0';
                    
                    // Measure text for proper box sizing
                    const textMetrics = ctx.measureText(displayText);
                    const textWidth = textMetrics.width;
                    const actualHeight = hotspot.fontSize;
                    
                    const labelWidth = textWidth + 20;
                    const labelHeight = actualHeight + 20;
                    
                    let labelX = x;
                    let labelY = y;
                    let lineEndX = x;
                    let lineEndY = y;
                    const lineLen = hotspot.lineLength || 60;
                    const textAlign = hotspot.textAlign || 'left';
                    
                    switch(hotspot.labelPosition) {
                        case 'right':
                            labelX = x + lineLen + 10;
                            // Anchor to left edge of box if text is left-aligned, right edge if right-aligned
                            lineEndX = textAlign === 'left' ? labelX : labelX + labelWidth;
                            lineEndY = y;
                            break;
                        case 'left':
                            labelX = x - lineLen - 10 - labelWidth;
                            // Anchor to right edge of box if text is left-aligned, left edge if right-aligned
                            lineEndX = textAlign === 'left' ? labelX + labelWidth : labelX;
                            lineEndY = y;
                            break;
                        case 'top':
                            labelX = x - labelWidth / 2;
                            labelY = y - lineLen - 10 - labelHeight;
                            lineEndX = x;
                            lineEndY = y - lineLen;
                            break;
                        case 'bottom':
                            labelX = x - labelWidth / 2;
                            labelY = y + lineLen + 10;
                            lineEndX = x;
                            lineEndY = y + lineLen;
                            break;
                    }
                    
                    // Draw line from marker to label - vertically centered with text
                    const textCenterY = labelY + labelHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    if (hotspot.labelPosition === 'right' || hotspot.labelPosition === 'left') {
                        ctx.lineTo(lineEndX, textCenterY);
                    } else {
                        ctx.lineTo(lineEndX, lineEndY);
                    }
                    ctx.strokeStyle = hotspot.markerColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw label background
                    ctx.fillStyle = 'rgba(26, 26, 26, 0.95)';
                    ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                    
                    // Draw text with shadow if enabled
                    if (hotspot.shadowBlur > 0) {
                        ctx.shadowBlur = hotspot.shadowBlur;
                        ctx.shadowColor = hotspot.shadowColor;
                    }
                    
                    ctx.fillStyle = '#e0e0e0';
                    
                    // Calculate text start position based on alignment
                    let textStartX = labelX + 10;
                    if (textAlign === 'right') {
                        textStartX = labelX + labelWidth - 10 - textWidth;
                    }
                    
                    // Apply letter spacing if needed
                    if (hotspot.letterSpacing !== 0) {
                        const chars = displayText.split('');
                        let currentX = textStartX;
                        chars.forEach(char => {
                            ctx.fillText(char, currentX, labelY + actualHeight + 5);
                            currentX += ctx.measureText(char).width + hotspot.letterSpacing;
                        });
                    } else {
                        ctx.fillText(displayText, textStartX, labelY + actualHeight + 5);
                    }
                }

                ctx.restore();
            });

            // Update caption - persists once shown
            const captionElement = document.getElementById('captionText');
            const captionFont = document.getElementById('captionFontFamily').value;
            let currentCaption = '';
            let currentCredit = '';
            
            if (captionEnabled) {
                // Find the last caption that should be showing (based on startScroll)
                hotspots.forEach(hotspot => {
                    const hotspotScrollStart = hotspot.startScroll / 100;
                    if (scrollProgress >= hotspotScrollStart) {
                        if (hotspot.caption) currentCaption = hotspot.caption;
                        if (hotspot.credit) currentCredit = hotspot.credit;
                    }
                });
            }

            if (captionEnabled && (currentCaption || currentCredit)) {
                captionElement.style.fontFamily = captionFont;
                let html = currentCaption;
                if (currentCredit) {
                    html += `<div class="caption-credit">${currentCredit}</div>`;
                }
                captionElement.innerHTML = html;
                captionElement.classList.add('visible');
            } else {
                captionElement.innerHTML = '';
                captionElement.classList.remove('visible');
            }
        }

        function generateEmbedCode() {
            if (!sourceImage) {
                document.getElementById('embedCode').value = '// Upload an image to generate embed code';
                return;
            }

            const width = parseInt(document.getElementById('widthInput').value) || 1920;
            const height = parseInt(document.getElementById('heightInput').value) || 1080;
            const scrollDuration = parseInt(document.getElementById('scrollDuration').value) || 2000;
            const imageFit = document.getElementById('imageFit').value;
            const captionFont = document.getElementById('captionFontFamily').value;
            const captionEnabledValue = document.getElementById('captionEnabled').checked;

            const customFontsLinks = customFonts.map(font => 
                `    <link rel="stylesheet" href="${font.url}">`
            ).join('\n');

            const hotspotsConfig = JSON.stringify(hotspots.map(h => ({
                x: h.x,
                y: h.y,
                label: h.label,
                description: h.description,
                caption: h.caption,
                credit: h.credit,
                startScroll: h.startScroll,
                endScroll: h.endScroll,
                fadeIn: h.fadeIn,
                fadeOut: h.fadeOut,
                markerColor: h.markerColor,
                lineLength: h.lineLength,
                labelPosition: h.labelPosition,
                textAlign: h.textAlign,
                fontSize: h.fontSize,
                fontFamily: h.fontFamily,
                textTransform: h.textTransform,
                letterSpacing: h.letterSpacing,
                lineHeight: h.lineHeight,
                shadowBlur: h.shadowBlur,
                shadowColor: h.shadowColor,
                clickAction: h.clickAction,
                clickUrl: h.clickUrl,
                clickScrollTo: h.clickScrollTo
            })), null, 12).replace(/\n/g, '\n            ');

            const code = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hotspots</title>
${customFontsLinks ? customFontsLinks + '\n' : ''}    <style>
        body { margin: 0; padding: 0; background: #000; }
        .hotspot-container {
            position: relative;
            width: 100%;
        }
        .hotspot-canvas-wrapper {
            position: sticky;
            top: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .hotspot-canvas {
            display: block;
            cursor: pointer;
        }
        .caption-text {
            position: relative;
            width: 85%;
            max-width: 700px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.9);
            color: #e0e0e0;
            font-size: 13px;
            line-height: 1.5;
            margin: 0 auto;
            display: none;
        }
        .caption-text.visible {
            display: block;
        }
        .caption-credit {
            color: #999;
            font-size: 11px;
            font-style: italic;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="hotspot-container" id="container">
        <div class="hotspot-canvas-wrapper">
            <canvas id="canvas" class="hotspot-canvas"></canvas>
            <div class="caption-text" id="captionText"></div>
        </div>
    </div>

    <script>
        const config = {
            width: ${width},
            height: ${height},
            scrollDuration: ${scrollDuration},
            imageFit: '${imageFit}',
            captionFont: '${captionFont}',
            captionEnabled: ${captionEnabledValue},
            imageData: '${imageDataUrl || ''}',
            hotspots: ${hotspotsConfig}
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        
        canvas.width = config.width;
        canvas.height = config.height;
        container.style.height = (config.height + config.scrollDuration) + 'px';

        const img = new Image();
        img.onload = () => render();
        img.src = config.imageData;

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;
            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x;
                    drawY = y;
                    drawWidth = width;
                    drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width;
                    drawHeight = img.height;
                    break;
            }
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        let animationFrame;
        function render() {
            const scrollTop = window.pageYOffset;
            const scrollProgress = Math.min(scrollTop / config.scrollDuration, 1);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawImageWithFit(ctx, img, 0, 0, canvas.width, canvas.height, config.imageFit);

            config.hotspots.forEach(hotspot => {
                const hotspotScrollStart = hotspot.startScroll / 100;
                const hotspotScrollEnd = hotspot.endScroll / 100;
                if (scrollProgress < hotspotScrollStart || scrollProgress > hotspotScrollEnd) return;

                const hotspotDuration = hotspotScrollEnd - hotspotScrollStart;
                const hotspotProgress = (scrollProgress - hotspotScrollStart) / hotspotDuration;
                let opacity = 1;
                if (hotspotProgress < hotspot.fadeIn / 100) opacity = hotspotProgress / (hotspot.fadeIn / 100);
                else if (hotspotProgress > 1 - (hotspot.fadeOut / 100)) opacity = (1 - hotspotProgress) / (hotspot.fadeOut / 100);

                const x = (hotspot.x / 100) * canvas.width;
                const y = (hotspot.y / 100) * canvas.height;

                ctx.save();
                ctx.globalAlpha = opacity;
                
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fillStyle = hotspot.markerColor;
                ctx.fill();

                if (hotspot.label) {
                    let displayText = hotspot.label;
                    switch(hotspot.textTransform) {
                        case 'uppercase': displayText = displayText.toUpperCase(); break;
                        case 'lowercase': displayText = displayText.toLowerCase(); break;
                        case 'capitalize': displayText = displayText.replace(/\\b\\w/g, l => l.toUpperCase()); break;
                    }

                    ctx.font = \`\${hotspot.fontSize}px \${hotspot.fontFamily}\`;
                    ctx.fillStyle = '#e0e0e0';
                    const textMetrics = ctx.measureText(displayText);
                    const textWidth = textMetrics.width;
                    const actualHeight = hotspot.fontSize;
                    const labelWidth = textWidth + 20;
                    const labelHeight = actualHeight + 20;
                    let labelX = x, labelY = y, lineEndX = x, lineEndY = y;
                    const lineLen = hotspot.lineLength || 60;
                    const textAlign = hotspot.textAlign || 'left';
                    
                    switch(hotspot.labelPosition) {
                        case 'right': 
                            labelX = x + lineLen + 10; 
                            lineEndX = textAlign === 'left' ? labelX : labelX + labelWidth;
                            lineEndY = y; 
                            break;
                        case 'left': 
                            labelX = x - lineLen - 10 - labelWidth; 
                            lineEndX = textAlign === 'left' ? labelX + labelWidth : labelX;
                            lineEndY = y; 
                            break;
                        case 'top': 
                            labelX = x - labelWidth / 2; 
                            labelY = y - lineLen - 10 - labelHeight; 
                            lineEndX = x; 
                            lineEndY = y - lineLen; 
                            break;
                        case 'bottom': 
                            labelX = x - labelWidth / 2; 
                            labelY = y + lineLen + 10; 
                            lineEndX = x; 
                            lineEndY = y + lineLen; 
                            break;
                    }
                    
                    const textCenterY = labelY + labelHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    if (hotspot.labelPosition === 'right' || hotspot.labelPosition === 'left') {
                        ctx.lineTo(lineEndX, textCenterY);
                    } else {
                        ctx.lineTo(lineEndX, lineEndY);
                    }
                    ctx.strokeStyle = hotspot.markerColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(26, 26, 26, 0.95)';
                    ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                    
                    if (hotspot.shadowBlur > 0) {
                        ctx.shadowBlur = hotspot.shadowBlur;
                        ctx.shadowColor = hotspot.shadowColor;
                    }
                    
                    ctx.fillStyle = '#e0e0e0';
                    let textStartX = labelX + 10;
                    if (textAlign === 'right') {
                        textStartX = labelX + labelWidth - 10 - textWidth;
                    }
                    
                    if (hotspot.letterSpacing !== 0) {
                        const chars = displayText.split('');
                        let currentX = textStartX;
                        chars.forEach(char => {
                            ctx.fillText(char, currentX, labelY + actualHeight + 5);
                            currentX += ctx.measureText(char).width + hotspot.letterSpacing;
                        });
                    } else {
                        ctx.fillText(displayText, textStartX, labelY + actualHeight + 5);
                    }
                }
                ctx.restore();
            });

            const captionElement = document.getElementById('captionText');
            let currentCaption = '';
            let currentCredit = '';
            
            if (config.captionEnabled) {
                config.hotspots.forEach(hotspot => {
                    const hotspotScrollStart = hotspot.startScroll / 100;
                    if (scrollProgress >= hotspotScrollStart) {
                        if (hotspot.caption) currentCaption = hotspot.caption;
                        if (hotspot.credit) currentCredit = hotspot.credit;
                    }
                });
            }

            if (config.captionEnabled && (currentCaption || currentCredit)) {
                captionElement.style.fontFamily = config.captionFont;
                let html = currentCaption;
                if (currentCredit) {
                    html += \`<div class="caption-credit">\${currentCredit}</div>\`;
                }
                captionElement.innerHTML = html;
                captionElement.classList.add('visible');
            } else {
                captionElement.innerHTML = '';
                captionElement.classList.remove('visible');
            }

            animationFrame = requestAnimationFrame(render);
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = ((e.clientX - rect.left) / rect.width) * 100;
            const clickY = ((e.clientY - rect.top) / rect.height) * 100;
            const scrollTop = window.pageYOffset;
            const scrollProgress = Math.min(scrollTop / config.scrollDuration, 1);

            config.hotspots.forEach(hotspot => {
                const hotspotScrollStart = hotspot.startScroll / 100;
                const hotspotScrollEnd = hotspot.endScroll / 100;
                if (scrollProgress < hotspotScrollStart || scrollProgress > hotspotScrollEnd) return;

                const distance = Math.sqrt(Math.pow(clickX - hotspot.x, 2) + Math.pow(clickY - hotspot.y, 2));
                if (distance < 5) {
                    if (hotspot.clickAction === 'url' && hotspot.clickUrl) {
                        window.open(hotspot.clickUrl, '_blank');
                    } else if (hotspot.clickAction === 'scroll') {
                        const targetScroll = (hotspot.clickScrollTo / 100) * config.scrollDuration;
                        window.scrollTo({ top: targetScroll, behavior: 'smooth' });
                    }
                }
            });
        });

        window.addEventListener('scroll', () => {
            if (!animationFrame) render();
        });
        render();
    <\/script>
</body>
</html>`;

            document.getElementById('embedCode').value = code;
        }

        function copyCode() {
            const textarea = document.getElementById('embedCode');
            textarea.select();
            document.execCommand('copy');
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadCode() {
            const code = document.getElementById('embedCode').value;
            const blob = new Blob([code], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'hotspots.html';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function saveProject() {
            const project = {
                version: 1,
                width: canvas.width,
                height: canvas.height,
                scrollDuration: parseInt(document.getElementById('scrollDuration').value),
                imageFit: document.getElementById('imageFit').value,
                captionFont: document.getElementById('captionFontFamily').value,
                captionEnabled: document.getElementById('captionEnabled').checked,
                autoCaption: autoCaption,
                hotspots: hotspots,
                customFonts: customFonts,
                imageData: imageDataUrl
            };

            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.download = 'hotspots-project.json';
            link.href = url;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const project = JSON.parse(event.target.result);
                        
                        document.getElementById('widthInput').value = project.width;
                        document.getElementById('heightInput').value = project.height;
                        document.getElementById('scrollDuration').value = project.scrollDuration;
                        document.getElementById('scrollDurationNumber').value = project.scrollDuration;
                        document.getElementById('scrollValue').textContent = project.scrollDuration;
                        if (project.imageFit) document.getElementById('imageFit').value = project.imageFit;
                        if (project.captionFont) document.getElementById('captionFontFamily').value = project.captionFont;
                        if (project.captionEnabled !== undefined) {
                            document.getElementById('captionEnabled').checked = project.captionEnabled;
                            captionEnabled = project.captionEnabled;
                        }
                        if (project.autoCaption) autoCaption = project.autoCaption;
                        
                        hotspots = project.hotspots || [];
                        customFonts = project.customFonts || [];
                        
                        hotspotIdCounter = hotspots.length > 0 ? Math.max(...hotspots.map(h => h.id)) + 1 : 0;
                        
                        customFonts.forEach(font => {
                            if (font.url) {
                                const link = document.createElement('link');
                                link.href = font.url;
                                link.rel = 'stylesheet';
                                document.head.appendChild(link);
                            }
                        });
                        
                        if (project.imageData) {
                            imageDataUrl = project.imageData;
                            loadImageFromDataUrl(project.imageData);
                        }
                        
                        updateHotspotsList();
                        updateCustomFontsList();
                        updateDimensionsInfo();
                        
                        alert('Project loaded successfully!');
                    } catch (err) {
                        alert('Error loading project: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        setInterval(renderPreview, 50);
        
        updateHotspotsList();
        generateEmbedCode();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Image Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 30px;
            align-items: start;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
            color: #fff;
        }

        h2 {
            font-size: 16px;
            margin: 24px 0 12px 0;
            color: #fff;
            border-bottom: 1px solid #2a2a2a;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 2px dashed #444;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
        }

        input[type="text"],
        input[type="number"],
        input[type="color"],
        select,
        textarea {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
        }

        textarea {
            min-height: 60px;
            resize: vertical;
            font-family: inherit;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            cursor: pointer;
        }

        .range-value {
            float: right;
            color: #888;
            font-size: 12px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        button:hover {
            background: #3a8eef;
        }

        button.secondary {
            background: #2a2a2a;
        }

        button.secondary:hover {
            background: #3a3a3a;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        /* Image Items */
        .image-item {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .image-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .image-item h3 {
            font-size: 13px;
            color: #4a9eff;
        }

        .image-controls {
            display: flex;
            gap: 6px;
        }

        .icon-btn {
            background: #2a2a2a;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 11px;
        }

        .icon-btn:hover {
            background: #3a3a3a;
        }

        .image-thumb {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
        }

        /* Preview */
        .preview-wrapper {
            background: #0a0a0a;
            border-radius: 12px;
            border: 1px solid #2a2a2a;
            height: calc(100vh - 40px);
            overflow-y: auto;
            position: relative;
        }

        .story-container {
            position: relative;
        }

        .sticky-stage {
            position: sticky;
            top: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-layer {
            position: absolute;
            width: 98%;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .image-layer.active {
            opacity: 1;
        }

        .image-layer img {
            width: 100%;
            height: auto;
            display: block;
        }

        .text-overlay {
            position: absolute;
            padding: 12px 20px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.8s ease;
            z-index: 10;
        }

        .image-layer.active .text-overlay {
            opacity: 1;
        }

        .caption-overlay {
            position: relative;
            width: 85%;
            max-width: 700px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.9);
            font-size: 13px;
            line-height: 1.5;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 20;
        }

        .image-layer.active .caption-overlay {
            opacity: 1;
        }

        .caption-overlay.active {
            opacity: 1;
        }

        .caption-credit {
            color: #999;
            font-size: 11px;
            font-style: italic;
            margin-top: 4px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        textarea.code {
            width: 100%;
            min-height: 400px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            padding: 16px;
            color: #4a9eff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            .controls {
                position: relative;
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel controls">
            <h1>Scrolltastic Image Gallery</h1>

            <div class="control-group">
                <label>Add Images</label>
                <input type="file" id="imageInput" accept="image/*" multiple>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button onclick="loadExampleGallery()" style="background: #9b59b6;">Load Example</button>
                    <button onclick="clearAllImages()" style="background: #e74c3c;">Clear All</button>
                </div>
            </div>

            <div class="control-group">
                <label>Or paste image URL</label>
                <input type="text" id="imageURL" placeholder="https://example.com/image.jpg">
                <button onclick="addFromURL()" style="margin-top: 8px;">Add from URL</button>
            </div>

            <h2>Global Settings</h2>
            
            <div class="control-group">
                <label>Image Fit</label>
                <select id="imageFit">
                    <option value="contain">Contain (fit inside)</option>
                    <option value="cover">Cover (fill)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Upload Custom Font (.ttf, .woff, .woff2)</label>
                <input type="file" id="fontUpload" accept=".ttf,.woff,.woff2,.otf">
                <button onclick="uploadFont()" style="margin-top: 8px;">Upload Font</button>
            </div>

            <div class="control-group">
                <label>Text Font Family</label>
                <select id="textFontFamily" onchange="renderPreview()">
                    <option value="inherit">System Default</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="Georgia, serif">Georgia</option>
                    <option value="'Courier New', monospace">Courier</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                </select>
            </div>

            <div class="control-group">
                <label>Caption Font Family</label>
                <select id="captionFontFamily" onchange="renderPreview()">
                    <option value="inherit">System Default</option>
                    <option value="Arial, sans-serif">Arial</option>
                    <option value="Georgia, serif">Georgia</option>
                    <option value="'Courier New', monospace">Courier</option>
                    <option value="'Times New Roman', serif">Times New Roman</option>
                    <option value="Verdana, sans-serif">Verdana</option>
                </select>
            </div>

            <div class="control-group">
                <label>Text Background Opacity <span class="range-value">80%</span></label>
                <input type="range" id="textOpacity" min="0" max="100" value="80" 
                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + '%'; renderPreview();">
            </div>

            <h2>Images</h2>
            <div id="imageList"></div>

            <button onclick="exportHTML()">Export HTML</button>
            <button class="secondary" onclick="clearAll()">Clear All</button>
        </div>

        <div class="panel">
            <h2>Preview</h2>
            <div class="preview-wrapper" id="preview"></div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h2>Export HTML</h2>
            <textarea class="code" id="exportCode" readonly></textarea>
            <button onclick="copyCode()">Copy Code</button>
            <button class="secondary" onclick="closeModal()">Close</button>
        </div>
    </div>

    <script>
        let images = [];
        let customFonts = [];

        // Load example gallery images
        async function loadExampleGallery() {
            const exampleURL = 'https://discophooey.github.io/my_personal_digital_team/examples/PLACE_HOLDER.png';
            
            images = [];
            for (let i = 1; i <= 3; i++) {
                images.push({
                    src: exampleURL,
                    text: `Example Image ${i}`,
                    caption: 'This is an example caption for the placeholder image',
                    link: ''
                });
            }
            
            renderImages();
            renderPreview();
            alert('‚úì Loaded 3 example images');
        }

        // Clear all images
        function clearAllImages() {
            if (images.length === 0) return;
            
            if (confirm('Clear all images?')) {
                images = [];
                renderImages();
                renderPreview();
                document.getElementById('imageInput').value = '';
            }
        }

        function uploadFont() {
            const input = document.getElementById('fontUpload');
            const file = input.files[0];
            
            if (!file) {
                alert('Please select a font file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const fontName = file.name.replace(/\.[^/.]+$/, "");
                const fontData = e.target.result;
                const format = file.name.endsWith('.woff2') ? 'woff2' : 
                              file.name.endsWith('.woff') ? 'woff' : 
                              file.name.endsWith('.otf') ? 'opentype' : 'truetype';
                
                // Create font face
                const fontFace = new FontFace(fontName, `url(${fontData})`, { format: format });
                fontFace.load().then(function(loadedFont) {
                    document.fonts.add(loadedFont);
                    
                    // Store font data
                    customFonts.push({
                        name: fontName,
                        data: fontData,
                        format: format
                    });
                    
                    // Add to both dropdowns
                    const textSelect = document.getElementById('textFontFamily');
                    const captionSelect = document.getElementById('captionFontFamily');
                    
                    const option1 = document.createElement('option');
                    option1.value = `"${fontName}"`;
                    option1.textContent = `${fontName} (Custom)`;
                    textSelect.appendChild(option1);
                    
                    const option2 = document.createElement('option');
                    option2.value = `"${fontName}"`;
                    option2.textContent = `${fontName} (Custom)`;
                    captionSelect.appendChild(option2);
                    
                    alert(`Font "${fontName}" uploaded successfully!`);
                    input.value = '';
                }).catch(function(error) {
                    alert('Failed to load font: ' + error);
                });
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('imageInput').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            files.forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    images.push({
                        id: Date.now() + i,
                        src: event.target.result,
                        name: file.name,
                        textEnabled: false,
                        text: '',
                        textSize: 32,
                        textColor: '#ffffff',
                        textAlign: 'center',
                        textPosition: 'bottom',
                        textX: 0,
                        textY: 0,
                        textBgEnabled: true,
                        textBgOpacity: 80,
                        textLineHeight: 1.4,
                        textLetterSpacing: 0,
                        captionEnabled: false,
                        caption: '',
                        credit: ''
                    });
                    if (images.length === files.length) {
                        render();
                    }
                };
                reader.readAsDataURL(file);
            });
            e.target.value = '';
        });

        function addFromURL() {
            const input = document.getElementById('imageURL');
            const url = input.value.trim();
            
            if (!url) {
                alert('Please enter an image URL');
                return;
            }
            
            // Test if URL is valid by loading it
            const img = new Image();
            img.onload = function() {
                images.push({
                    id: Date.now(),
                    src: url,
                    name: url.split('/').pop() || 'Image',
                    textEnabled: false,
                    text: '',
                    textSize: 32,
                    textColor: '#ffffff',
                    textAlign: 'center',
                    textPosition: 'bottom',
                    textX: 0,
                    textY: 0,
                    textBgEnabled: true,
                    textBgOpacity: 80,
                    textLineHeight: 1.4,
                    textLetterSpacing: 0,
                    captionEnabled: false,
                    caption: '',
                    credit: ''
                });
                input.value = '';
                render();
            };
            img.onerror = function() {
                alert('Could not load image from URL. Please check the link.');
            };
            img.src = url;
        }

        function render() {
            renderList();
            renderPreview();
        }

        function renderList() {
            const list = document.getElementById('imageList');
            if (images.length === 0) {
                list.innerHTML = '<p style="color: #666; font-size: 12px;">No images added</p>';
                return;
            }

            list.innerHTML = images.map((img, i) => {
                const escapeHtml = (str) => str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                return `
                <div class="image-item">
                    <div class="image-item-header">
                        <h3>Image ${i + 1}</h3>
                        <div class="image-controls">
                            ${i > 0 ? `<button class="icon-btn" onclick="move(${i}, -1)">‚Üë</button>` : ''}
                            ${i < images.length - 1 ? `<button class="icon-btn" onclick="move(${i}, 1)">‚Üì</button>` : ''}
                            <button class="icon-btn" onclick="remove(${i})">√ó</button>
                        </div>
                    </div>
                    <img src="${img.src}" class="image-thumb">
                    
                    <label><input type="checkbox" ${img.textEnabled ? 'checked' : ''} onchange="toggle(${i}, 'textEnabled')">Text Overlay</label>
                    ${img.textEnabled ? `
                        <div class="control-group">
                            <textarea placeholder="Text..." onchange="update(${i}, 'text', this.value)">${escapeHtml(img.text)}</textarea>
                        </div>
                        <div class="grid-2">
                            <div class="control-group">
                                <label>Size <span class="range-value">${img.textSize}px</span></label>
                                <input type="range" min="16" max="80" value="${img.textSize}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + 'px'"
                                    onchange="update(${i}, 'textSize', parseInt(this.value))">
                            </div>
                            <div class="control-group">
                                <label>Color</label>
                                <input type="color" value="${img.textColor}" onchange="update(${i}, 'textColor', this.value)">
                            </div>
                        </div>
                        <div class="grid-2">
                            <div class="control-group">
                                <label>Position</label>
                                <select onchange="update(${i}, 'textPosition', this.value)">
                                    <option value="top" ${img.textPosition === 'top' ? 'selected' : ''}>Top</option>
                                    <option value="center" ${img.textPosition === 'center' ? 'selected' : ''}>Center</option>
                                    <option value="bottom" ${img.textPosition === 'bottom' ? 'selected' : ''}>Bottom</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Align</label>
                                <select onchange="update(${i}, 'textAlign', this.value)">
                                    <option value="left" ${img.textAlign === 'left' ? 'selected' : ''}>Left</option>
                                    <option value="center" ${img.textAlign === 'center' ? 'selected' : ''}>Center</option>
                                    <option value="right" ${img.textAlign === 'right' ? 'selected' : ''}>Right</option>
                                    <option value="justify" ${img.textAlign === 'justify' ? 'selected' : ''}>Justify</option>
                                    <option value="justify-left" ${img.textAlign === 'justify-left' ? 'selected' : ''}>Justify Left</option>
                                    <option value="justify-right" ${img.textAlign === 'justify-right' ? 'selected' : ''}>Justify Right</option>
                                </select>
                            </div>
                        </div>
                        <div class="grid-2">
                            <div class="control-group">
                                <label>Line Height <span class="range-value">${img.textLineHeight || 1.4}</span></label>
                                <input type="range" min="1" max="2.5" step="0.1" value="${img.textLineHeight || 1.4}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value"
                                    onchange="update(${i}, 'textLineHeight', parseFloat(this.value))">
                            </div>
                            <div class="control-group">
                                <label>Letter Spacing <span class="range-value">${img.textLetterSpacing || 0}px</span></label>
                                <input type="range" min="-2" max="10" value="${img.textLetterSpacing || 0}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + 'px'"
                                    onchange="update(${i}, 'textLetterSpacing', parseInt(this.value))">
                            </div>
                        </div>
                        <div class="grid-2">
                            <div class="control-group">
                                <label>X Offset <span class="range-value">${img.textX || 0}px</span></label>
                                <input type="range" min="-300" max="300" value="${img.textX || 0}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + 'px'"
                                    onchange="update(${i}, 'textX', parseInt(this.value))">
                            </div>
                            <div class="control-group">
                                <label>Y Offset <span class="range-value">${img.textY || 0}px</span></label>
                                <input type="range" min="-300" max="300" value="${img.textY || 0}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + 'px'"
                                    onchange="update(${i}, 'textY', parseInt(this.value))">
                            </div>
                        </div>
                        <div class="grid-2">
                            <div class="control-group">
                                <label><input type="checkbox" ${img.textBgEnabled !== false ? 'checked' : ''} onchange="toggle(${i}, 'textBgEnabled')">Background</label>
                            </div>
                            <div class="control-group" ${img.textBgEnabled !== false ? '' : 'style="opacity: 0.5;"'}>
                                <label>BG Opacity <span class="range-value">${img.textBgOpacity !== undefined ? img.textBgOpacity : 80}%</span></label>
                                <input type="range" min="0" max="100" value="${img.textBgOpacity !== undefined ? img.textBgOpacity : 80}" 
                                    oninput="this.previousElementSibling.querySelector('.range-value').textContent = this.value + '%'"
                                    onchange="update(${i}, 'textBgOpacity', parseInt(this.value))"
                                    ${img.textBgEnabled !== false ? '' : 'disabled'}>
                            </div>
                        </div>
                    ` : ''}
                    
                    <label style="margin-top: 10px;"><input type="checkbox" ${img.captionEnabled ? 'checked' : ''} onchange="toggle(${i}, 'captionEnabled')">Caption</label>
                    ${img.captionEnabled ? `
                        <div class="control-group">
                            <textarea placeholder="Caption text..." onchange="update(${i}, 'caption', this.value)">${escapeHtml(img.caption)}</textarea>
                        </div>
                        <div class="control-group">
                            <input type="text" placeholder="Credit/Source" value="${escapeHtml(img.credit)}" onchange="update(${i}, 'credit', this.value)">
                        </div>
                    ` : ''}
                </div>
            `;
            }).join('');
        }

        function renderPreview() {
            const preview = document.getElementById('preview');
            const fit = document.getElementById('imageFit').value;
            const textFont = document.getElementById('textFontFamily').value;
            const captionFont = document.getElementById('captionFontFamily').value;
            
            if (images.length === 0) {
                preview.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;">Add images to preview</div>';
                return;
            }

            const height = images.length * 100;
            let html = `<div class="story-container" style="height: ${height}vh;"><div class="sticky-stage">`;
            
            images.forEach((img, i) => {
                html += `<div class="image-layer" data-index="${i}">`;
                html += `<img src="${img.src}" style="object-fit: ${fit};">`;
                
                if (img.textEnabled && img.text) {
                    let pos = '';
                    if (img.textPosition === 'top') pos = 'top: 20px;';
                    else if (img.textPosition === 'center') pos = 'top: 50%; transform: translate(-50%, -50%);';
                    else pos = 'bottom: 20px;';
                    
                    const xOffset = img.textX || 0;
                    const yOffset = img.textY || 0;
                    const bgOpacity = (img.textBgOpacity !== undefined ? img.textBgOpacity : 80) / 100;
                    const lineHeight = img.textLineHeight || 1.4;
                    const letterSpacing = img.textLetterSpacing || 0;
                    const bgStyle = img.textBgEnabled !== false ? `background: rgba(0,0,0,${bgOpacity}); backdrop-filter: blur(10px);` : '';
                    
                    // Handle text alignment including justify variations
                    let textAlign = img.textAlign;
                    let textAlignLast = '';
                    if (img.textAlign === 'justify-left') {
                        textAlign = 'justify';
                        textAlignLast = 'text-align-last: left;';
                    } else if (img.textAlign === 'justify-right') {
                        textAlign = 'justify';
                        textAlignLast = 'text-align-last: right;';
                    }
                    
                    html += `<div class="text-overlay" style="${pos} left: 50%; transform: translateX(-50%); margin-left: ${xOffset}px; margin-top: ${yOffset}px; font-size: ${img.textSize}px; color: ${img.textColor}; text-align: ${textAlign}; ${textAlignLast} font-family: ${textFont}; line-height: ${lineHeight}; letter-spacing: ${letterSpacing}px; ${bgStyle}">${img.text.replace(/\n/g, '<br>')}</div>`;
                }
                
                if (img.captionEnabled && (img.caption || img.credit)) {
                    html += `<div class="caption-overlay" style="font-family: ${captionFont};">${img.caption ? img.caption : ''}${img.credit ? `<div class="caption-credit">${img.credit}</div>` : ''}</div>`;
                }
                
                html += `</div>`;
            });
            
            html += `</div></div>`;
            preview.innerHTML = html;
            
            preview.addEventListener('scroll', updateActive);
            updateActive();
        }

        function updateActive() {
            const preview = document.getElementById('preview');
            const scroll = preview.scrollTop;
            const height = preview.clientHeight;
            
            images.forEach((img, i) => {
                const start = i * height;
                const end = (i + 1) * height;
                const layer = preview.querySelector(`.image-layer[data-index="${i}"]`);
                
                if (scroll >= start && scroll < end) {
                    if (layer) layer.classList.add('active');
                } else {
                    if (layer) layer.classList.remove('active');
                }
            });
        }

        function toggle(i, prop) {
            images[i][prop] = !images[i][prop];
            render();
        }

        function update(i, prop, value) {
            images[i][prop] = value;
            renderPreview();
        }

        function move(i, dir) {
            const newI = i + dir;
            [images[i], images[newI]] = [images[newI], images[i]];
            render();
        }

        function remove(i) {
            if (confirm('Delete this image?')) {
                images.splice(i, 1);
                render();
            }
        }

        function clearAll() {
            if (confirm('Clear all images?')) {
                images = [];
                render();
            }
        }

        function exportHTML() {
            const fit = document.getElementById('imageFit').value;
            const textFont = document.getElementById('textFontFamily').value;
            const captionFont = document.getElementById('captionFontFamily').value;
            const height = images.length * 100;
            
            let layers = '';
            
            images.forEach((img, i) => {
                layers += `<div class="image-layer" data-index="${i}"><img src="${img.src}" style="object-fit: ${fit};">`;
                
                if (img.textEnabled && img.text) {
                    let pos = '';
                    if (img.textPosition === 'top') pos = 'top: 20px;';
                    else if (img.textPosition === 'center') pos = 'top: 50%; transform: translate(-50%, -50%);';
                    else pos = 'bottom: 20px;';
                    
                    const xOffset = img.textX || 0;
                    const yOffset = img.textY || 0;
                    const bgOpacity = (img.textBgOpacity !== undefined ? img.textBgOpacity : 80) / 100;
                    const lineHeight = img.textLineHeight || 1.4;
                    const letterSpacing = img.textLetterSpacing || 0;
                    const bgStyle = img.textBgEnabled !== false ? `background: rgba(0,0,0,${bgOpacity}); backdrop-filter: blur(10px);` : '';
                    
                    // Handle text alignment including justify variations
                    let textAlign = img.textAlign;
                    let textAlignLast = '';
                    if (img.textAlign === 'justify-left') {
                        textAlign = 'justify';
                        textAlignLast = 'text-align-last: left;';
                    } else if (img.textAlign === 'justify-right') {
                        textAlign = 'justify';
                        textAlignLast = 'text-align-last: right;';
                    }
                    
                    layers += `<div class="text-overlay" style="${pos} left: 50%; transform: translateX(-50%); margin-left: ${xOffset}px; margin-top: ${yOffset}px; font-size: ${img.textSize}px; color: ${img.textColor}; text-align: ${textAlign}; ${textAlignLast} font-family: ${textFont}; line-height: ${lineHeight}; letter-spacing: ${letterSpacing}px; ${bgStyle}">${img.text.replace(/\n/g, '<br>')}</div>`;
                }
                
                if (img.captionEnabled && (img.caption || img.credit)) {
                    layers += `<div class="caption-overlay" style="font-family: ${captionFont};">${img.caption ? img.caption : ''}${img.credit ? `<div class="caption-credit">${img.credit}</div>` : ''}</div>`;
                }
                
                layers += `</div>`;
            });

            const code = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrolltastic Gallery</title>
    <style>
        ${customFonts.map(font => `
        @font-face {
            font-family: "${font.name}";
            src: url(${font.data}) format('${font.format}');
        }`).join('')}
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; overflow-x: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        
        /* Instructions Page */
        .instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        .instructions.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        .instructions-content {
            max-width: 600px;
            padding: 40px;
            text-align: center;
        }
        .instructions h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .instructions p {
            font-size: 18px;
            line-height: 1.6;
            color: #b8b8d1;
            margin-bottom: 30px;
        }
        .instructions button {
            padding: 16px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .instructions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .instructions .tip {
            margin-top: 20px;
            font-size: 14px;
            color: #8b8ba7;
        }
        
        /* Gallery Styles */
        .story-container { position: relative; height: ${height}vh; }
        .sticky-stage { position: sticky; top: 0; width: 100%; height: 100vh; display: flex; align-items: center; justify-content: center; }
        .image-layer { position: absolute; width: 98%; display: flex; flex-direction: column; align-items: center; opacity: 0; transition: opacity 0.5s; }
        .image-layer.active { opacity: 1; }
        .image-layer img { width: 100%; height: auto; display: block; }
        .text-overlay { position: absolute; padding: 12px 20px; border-radius: 4px; opacity: 0; transition: opacity 0.8s ease; z-index: 10; }
        .image-layer.active .text-overlay { opacity: 1; }
        .caption-overlay { position: relative; width: 85%; max-width: 700px; padding: 10px 16px; background: rgba(0,0,0,0.9); font-size: 13px; line-height: 1.5; opacity: 0; transition: opacity 0.5s; z-index: 20; }
        .image-layer.active .caption-overlay { opacity: 1; }
        .caption-overlay.active { opacity: 1; }
        .caption-credit { color: #999; font-size: 11px; font-style: italic; margin-top: 4px; }
    </style>
</head>
<body>
    <!-- Instructions Page -->
    <div class="instructions" id="instructions">
        <div class="instructions-content">
            <h1>Scrolltastic Gallery</h1>
            <p>Welcome! This is an interactive scroll-based image gallery.</p>
            <p><strong>How to view:</strong><br>Simply scroll down to experience the gallery. Each image will fade in as you scroll.</p>
            <p><strong>Compatible with:</strong><br>All modern browsers on desktop, tablet, and mobile devices.</p>
            <button onclick="document.getElementById('instructions').classList.add('hidden')">Start Gallery ‚Üí</button>
            <p class="tip">üí° Works offline ‚Ä¢ No installation needed ‚Ä¢ Share this file with anyone</p>
        </div>
    </div>

    <!-- Gallery Content -->
    <div class="story-container">
        <div class="sticky-stage">
            ${layers}
        </div>
    </div>
    <scr` + `ipt>
        function update() {
            const scroll = window.pageYOffset;
            const height = window.innerHeight;
            const total = ${images.length};
            for (let i = 0; i < total; i++) {
                const start = i * height;
                const end = (i + 1) * height;
                const layer = document.querySelector('.image-layer[data-index="' + i + '"]');
                if (scroll >= start && scroll < end) {
                    if (layer) layer.classList.add('active');
                } else {
                    if (layer) layer.classList.remove('active');
                }
            }
        }
        window.addEventListener('scroll', update);
        update();
    </scr` + `ipt>
</body>
</html>`;

            document.getElementById('exportCode').value = code;
            document.getElementById('exportModal').classList.add('active');
        }

        function copyCode() {
            document.getElementById('exportCode').select();
            document.execCommand('copy');
            alert('Copied!');
        }

        function closeModal() {
            document.getElementById('exportModal').classList.remove('active');
        }
    </script>
</body>
</html>
