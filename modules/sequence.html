<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantastic Scrolltastic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            align-items: start;
        }

        .panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #2a2a2a;
        }

        .controls {
            position: sticky;
            top: 20px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 24px;
            color: #fff;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 16px;
            color: #fff;
            border-bottom: 1px solid #2a2a2a;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="file"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 2px dashed #444;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
        }

        input[type="file"]:hover {
            border-color: #666;
            background: #333;
        }

        input[type="number"],
        input[type="range"],
        select {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #888;
            font-size: 13px;
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            transform: scale(0.98);
        }

        .preview-container {
            position: relative;
        }

        .preview-wrapper {
            background: #0a0a0a;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #2a2a2a;
            height: 600px;
            overflow-y: scroll;
        }

        .preview-scroll-content {
            position: relative;
        }

        #previewCanvas {
            display: block;
            margin: 0 auto;
            position: sticky;
            top: 0;
        }

        .scroll-indicator {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 14px;
        }

        .file-info {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        .preset-info {
            display: inline-block;
            margin-left: 10px;
            font-size: 11px;
            color: #888;
            font-style: italic;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            color: #4a9eff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .copy-btn {
            margin-top: 10px;
            background: #2a2a2a;
        }

        .copy-btn:hover {
            background: #3a3a3a;
        }

        .code-section {
            margin-top: 20px;
        }

        .text-overlay-item {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .text-overlay-item h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #4a9eff;
        }

        .remove-text-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4444;
            padding: 5px 10px;
            font-size: 12px;
            width: auto;
        }

        .remove-text-btn:hover {
            background: #cc0000;
        }

        textarea.text-input {
            min-height: 60px;
            resize: vertical;
        }

        .frame-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                position: relative;
                top: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel controls">
            <h1>Fantastic Scrolltastic</h1>
            
            <div class="control-group">
                <label>Load Images</label>
                <select id="loadMethod" onchange="toggleLoadMethod()">
                    <option value="upload">Upload from Local</option>
                    <option value="url">Load from URL Folder</option>
                </select>
            </div>

            <div class="control-group" id="uploadSection">
                <label>Upload Image Sequence</label>
                <input type="file" id="imageInput" multiple accept="image/*">
                <div class="file-info" id="fileInfo">No files selected</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <button onclick="loadExampleSequence()" style="background: #9b59b6;">Load Example</button>
                    <button onclick="clearAllFrames()" style="background: #e74c3c;">Clear All</button>
                </div>
            </div>

            <div class="control-group" id="urlSection" style="display: none;">
                <label>Image Folder URL Pattern</label>
                <input type="text" id="urlPattern" placeholder="https://example.com/images/frame{001-050}.jpg">
                <div class="file-info">Use {start-end} for number range (e.g., {001-030})</div>
                <button onclick="loadFromURL()" style="margin-top: 10px;">Load Images</button>
            </div>

            <div class="control-group">
                <label>Aspect Ratio Presets</label>
                <select id="aspectRatio" onchange="applyAspectRatio()">
                    <option value="custom">Custom</option>
                    <option value="9:16">Vertical Phone (9:16)</option>
                    <option value="16:9">Widescreen Phone (16:9)</option>
                    <option value="4:3">Desktop Standard (4:3)</option>
                    <option value="16:10">Desktop Wide (16:10)</option>
                    <option value="21:9">Ultrawide (21:9)</option>
                    <option value="1:1">Square (1:1)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Dimensions</label>
                <div class="dimension-inputs">
                    <div>
                        <input type="number" id="widthInput" placeholder="Width" value="800">
                    </div>
                    <div>
                        <input type="number" id="heightInput" placeholder="Height" value="600">
                    </div>
                </div>
                <div class="file-info" id="dimensionsInfo">800 x 600 (4:3 ratio)</div>
            </div>

            <div class="control-group">
                <label>Object Fit</label>
                <select id="objectFit">
                    <option value="contain">Contain</option>
                    <option value="cover">Cover</option>
                    <option value="fill">Fill</option>
                    <option value="none">None</option>
                </select>
            </div>

            <div class="control-group">
                <label>Scroll Speed <span class="range-value" id="speedValue">1.0x</span></label>
                <input type="range" id="scrollSpeed" min="0.1" max="3" step="0.1" value="1">
            </div>

            <div class="code-section">
                <h2>Custom Fonts</h2>
                <div class="control-group">
                    <label>Google Fonts URL or Font Name</label>
                    <input type="text" id="customFontInput" placeholder="e.g., Playfair Display or https://fonts.googleapis.com/css2?family=...">
                    <button onclick="addCustomFont()" style="margin-top: 10px;">Add Font</button>
                </div>
                <div id="customFontsList" class="file-info"></div>
            </div>

            <button onclick="updatePreview()">Update Preview</button>

            <div class="code-section">
                <h2>Text Overlays</h2>
                <button onclick="addTextOverlay()" style="background: #34a853; margin-bottom: 15px;">+ Add Text</button>
                <div id="textOverlaysList"></div>
            </div>

            <div class="code-section">
                <h2>Embed Code</h2>
                <textarea id="embedCode" readonly></textarea>
                <button class="copy-btn" onclick="copyCode()">Copy to Clipboard</button>
                <button class="copy-btn" onclick="downloadInstructions()" style="background: #34a853; margin-top: 10px;">Download Instructions (.txt)</button>
            </div>
        </div>

        <div class="panel preview-container">
            <h2>Preview</h2>
            <div class="preview-wrapper" id="previewWrapper">
                <div class="preview-scroll-content" id="scrollContent">
                    <canvas id="previewCanvas"></canvas>
                    <div class="scroll-indicator">
                        Upload images to preview scroll animation
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let images = [];
        let loadedImages = [];
        let textOverlays = [];
        let overlayIdCounter = 0;
        let customFonts = [];
        let currentConfig = {
            width: 800,
            height: 600,
            objectFit: 'contain',
            scrollSpeed: 1.0
        };

        const aspectRatioPresets = {
            '9:16': { width: 1080, height: 1920, name: 'Vertical Phone' },     // Instagram/TikTok vertical
            '16:9': { width: 1920, height: 1080, name: 'Widescreen Phone' },   // Landscape video
            '4:3': { width: 1024, height: 768, name: 'Desktop Standard' },     // Traditional desktop
            '16:10': { width: 1920, height: 1200, name: 'Desktop Wide' },      // MacBook ratio
            '21:9': { width: 2560, height: 1080, name: 'Ultrawide' },          // Ultrawide monitor
            '1:1': { width: 1080, height: 1080, name: 'Square' }               // Instagram square
        };

        // Load example sequence from GitHub
        async function loadExampleSequence() {
            const baseURL = 'https://discophooey.github.io/my_personal_digital_team/examples/examples/sequence/';
            const totalFrames = 20;
            
            images = [];
            loadedImages = [];
            
            document.getElementById('fileInfo').textContent = 'Loading example frames...';
            
            try {
                for (let i = 1; i <= totalFrames; i++) {
                    const frameNum = String(i).padStart(2, '0');
                    const url = `${baseURL}frame-${frameNum}.png`;
                    
                    console.log('Attempting to load:', url); // Debug log
                    
                    const img = new Image();
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            console.log('✓ Loaded:', url); // Debug log
                            images.push({ src: url, file: { name: `frame-${frameNum}.png` } });
                            loadedImages.push(img);
                            document.getElementById('fileInfo').textContent = `Loading ${i}/${totalFrames} frames...`;
                            resolve();
                        };
                        img.onerror = (error) => {
                            console.error('✗ Failed to load:', url, error); // Debug log
                            reject(new Error(`Failed to load frame ${i} from ${url}`));
                        };
                        img.src = url;
                    });
                }
                
                // Set 16:9 dimensions for example
                document.getElementById('widthInput').value = 1920;
                document.getElementById('heightInput').value = 1080;
                document.getElementById('aspectRatio').value = '16:9';
                checkCustomAspectRatio();
                
                document.getElementById('fileInfo').textContent = `✓ Loaded ${totalFrames} example frames`;
                updatePreview();
                
            } catch (error) {
                console.error('Full error:', error); // Debug log
                document.getElementById('fileInfo').textContent = '✗ ' + error.message;
                alert('Failed to load examples. Check console (F12) for details.\n\nTried URL: ' + baseURL + 'frame-01.png\n\nPlease verify:\n1. Files uploaded to GitHub\n2. GitHub Pages rebuilt (wait 2 min)\n3. Try visiting the URL directly in browser');
            }
        }

        // Clear all frames
        function clearAllFrames() {
            if (images.length === 0 && textOverlays.length === 0) {
                return;
            }
            
            if (confirm('Clear all frames and text overlays?')) {
                images = [];
                loadedImages = [];
                textOverlays = [];
                document.getElementById('fileInfo').textContent = 'No files selected';
                document.getElementById('imageInput').value = '';
                updatePreview();
                renderTextOverlays();
            }
        }

        function applyAspectRatio() {
            const selected = document.getElementById('aspectRatio').value;
            
            if (selected === 'custom') {
                return;
            }
            
            const preset = aspectRatioPresets[selected];
            if (preset) {
                document.getElementById('widthInput').value = preset.width;
                document.getElementById('heightInput').value = preset.height;
            }
        }

        // Update aspect ratio dropdown when dimensions change manually
        document.getElementById('widthInput').addEventListener('input', checkCustomAspectRatio);
        document.getElementById('heightInput').addEventListener('input', checkCustomAspectRatio);

        function checkCustomAspectRatio() {
            const width = parseInt(document.getElementById('widthInput').value);
            const height = parseInt(document.getElementById('heightInput').value);
            
            if (!width || !height) {
                document.getElementById('dimensionsInfo').textContent = 'Enter dimensions';
                return;
            }
            
            // Calculate GCD for ratio display
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const divisor = gcd(width, height);
            const ratioW = width / divisor;
            const ratioH = height / divisor;
            
            // Check if current dimensions match a preset
            let matchesPreset = false;
            let presetName = '';
            for (const [ratio, preset] of Object.entries(aspectRatioPresets)) {
                if (preset.width === width && preset.height === height) {
                    document.getElementById('aspectRatio').value = ratio;
                    matchesPreset = true;
                    presetName = preset.name;
                    break;
                }
            }
            
            if (matchesPreset) {
                document.getElementById('dimensionsInfo').textContent = 
                    `${width} x ${height} (${ratioW}:${ratioH} - ${presetName})`;
            } else {
                document.getElementById('aspectRatio').value = 'custom';
                document.getElementById('dimensionsInfo').textContent = 
                    `${width} x ${height} (${ratioW}:${ratioH} ratio)`;
            }
        }

        function addCustomFont() {
            const input = document.getElementById('customFontInput');
            const value = input.value.trim();
            
            if (!value) {
                alert('Please enter a font name or Google Fonts URL');
                return;
            }
            
            let fontName, fontUrl;
            
            // Check if it's a URL
            if (value.startsWith('http://') || value.startsWith('https://')) {
                fontUrl = value;
                // Try to extract font name from Google Fonts URL
                const match = value.match(/family=([^:&]+)/);
                if (match) {
                    fontName = decodeURIComponent(match[1]).replace(/\+/g, ' ');
                } else {
                    fontName = prompt('Enter the font family name (e.g., "Playfair Display"):');
                    if (!fontName) return;
                }
            } else {
                // It's a font name - construct Google Fonts URL
                fontName = value;
                const urlSafeName = fontName.replace(/\s+/g, '+');
                fontUrl = `https://fonts.googleapis.com/css2?family=${urlSafeName}:wght@400;700&display=swap`;
            }
            
            // Check if font already exists
            if (customFonts.some(f => f.name === fontName)) {
                alert('This font is already added');
                return;
            }
            
            // Add font link to document
            const link = document.createElement('link');
            link.href = fontUrl;
            link.rel = 'stylesheet';
            document.head.appendChild(link);
            
            // Add to custom fonts array
            customFonts.push({ name: fontName, url: fontUrl });
            
            // Clear input and update display
            input.value = '';
            updateCustomFontsList();
            
            // Update text overlay controls to include new font
            if (textOverlays.length > 0) {
                renderTextOverlaysList();
            }
        }
        
        function removeCustomFont(fontName) {
            customFonts = customFonts.filter(f => f.name !== fontName);
            updateCustomFontsList();
            renderTextOverlaysList();
        }
        
        function updateCustomFontsList() {
            const container = document.getElementById('customFontsList');
            if (customFonts.length === 0) {
                container.innerHTML = 'No custom fonts loaded';
                return;
            }
            
            container.innerHTML = customFonts.map(font => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #2a2a2a;">
                    <span style="font-family: '${font.name}'; font-size: 14px;">${font.name}</span>
                    <button onclick="removeCustomFont('${font.name.replace(/'/g, "\\'")}')" 
                            style="background: #ff4444; padding: 3px 8px; font-size: 11px; width: auto;">Remove</button>
                </div>
            `).join('');
        }

        function addTextOverlay() {
            const id = overlayIdCounter++;
            textOverlays.push({
                id: id,
                text: 'Your text here',
                startFrame: 0,
                endFrame: Math.max(10, loadedImages.length - 1),
                fadeInFrames: 5,
                fadeOutFrames: 5,
                fontSize: 24,
                fontFamily: 'Arial',
                color: '#ffffff',
                align: 'center',
                verticalAlign: 'middle',
                textTransform: 'none',
                letterSpacing: 0,
                lineHeight: 1.2,
                xOffset: 0,
                yOffset: 0,
                shadowBlur: 0,
                shadowColor: '#000000'
            });
            renderTextOverlaysList();
            updatePreview();
        }

        function duplicateTextOverlay(id) {
            const original = textOverlays.find(t => t.id === id);
            if (original) {
                const newId = overlayIdCounter++;
                const duplicate = {
                    ...original,
                    id: newId,
                    text: original.text + ' (copy)'
                };
                textOverlays.push(duplicate);
                renderTextOverlaysList();
                updatePreview();
            }
        }

        function removeTextOverlay(id) {
            textOverlays = textOverlays.filter(t => t.id !== id);
            renderTextOverlaysList();
            updatePreview();
        }

        function updateTextOverlay(id, field, value) {
            const overlay = textOverlays.find(t => t.id === id);
            if (overlay) {
                if (field === 'fontSize' || field === 'startFrame' || field === 'endFrame' || 
                    field === 'fadeInFrames' || field === 'fadeOutFrames' || field === 'letterSpacing' || 
                    field === 'lineHeight' || field === 'shadowBlur' || 
                    field === 'xOffset' || field === 'yOffset') {
                    overlay[field] = parseFloat(value) || 0;
                } else {
                    overlay[field] = value;
                }
                updatePreview();
            }
        }

        function renderTextOverlaysList() {
            const container = document.getElementById('textOverlaysList');
            const maxFrames = Math.max(1, loadedImages.length - 1);
            
            container.innerHTML = textOverlays.map(overlay => `
                <div class="text-overlay-item">
                    <h3>Text Overlay ${overlay.id + 1}</h3>
                    <button class="remove-text-btn" onclick="removeTextOverlay(${overlay.id})">Remove</button>
                    <button class="remove-text-btn" onclick="duplicateTextOverlay(${overlay.id})" 
                            style="right: 90px; background: #34a853;">Duplicate</button>
                    
                    <div class="control-group">
                        <label>Text Content</label>
                        <textarea class="text-input" oninput="updateTextOverlay(${overlay.id}, 'text', this.value)">${overlay.text}</textarea>
                    </div>

                    <div class="control-group">
                        <label>Frame Range (0-${maxFrames})</label>
                        <div class="frame-range">
                            <input type="number" min="0" max="${maxFrames}" value="${overlay.startFrame}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'startFrame', this.value)" placeholder="Start">
                            <input type="number" min="0" max="${maxFrames}" value="${overlay.endFrame}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'endFrame', this.value)" placeholder="End">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Fade In/Out (frames)</label>
                        <div class="frame-range">
                            <input type="number" min="0" max="20" value="${overlay.fadeInFrames}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'fadeInFrames', this.value)" placeholder="Fade In">
                            <input type="number" min="0" max="20" value="${overlay.fadeOutFrames}" 
                                   onchange="updateTextOverlay(${overlay.id}, 'fadeOutFrames', this.value)" placeholder="Fade Out">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Font Size</label>
                        <input type="number" value="${overlay.fontSize}" 
                               onchange="updateTextOverlay(${overlay.id}, 'fontSize', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Font Family</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'fontFamily', this.value)">
                            <option value="Arial" ${overlay.fontFamily === 'Arial' ? 'selected' : ''}>Arial</option>
                            <option value="Helvetica" ${overlay.fontFamily === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                            <option value="-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif" ${overlay.fontFamily === '-apple-system, BlinkMacSystemFont, \'Segoe UI\', sans-serif' ? 'selected' : ''}>System (Apple/SF Pro)</option>
                            <option value="Georgia" ${overlay.fontFamily === 'Georgia' ? 'selected' : ''}>Georgia</option>
                            <option value="Times New Roman" ${overlay.fontFamily === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                            <option value="Courier New" ${overlay.fontFamily === 'Courier New' ? 'selected' : ''}>Courier New</option>
                            <option value="Verdana" ${overlay.fontFamily === 'Verdana' ? 'selected' : ''}>Verdana</option>
                            <option value="Impact" ${overlay.fontFamily === 'Impact' ? 'selected' : ''}>Impact</option>
                            ${customFonts.length > 0 ? '<option disabled>--- Custom Fonts ---</option>' : ''}
                            ${customFonts.map(font => `<option value="${font.name}" ${overlay.fontFamily === font.name ? 'selected' : ''}>${font.name}</option>`).join('')}
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Text Color</label>
                        <input type="color" value="${overlay.color}" 
                               onchange="updateTextOverlay(${overlay.id}, 'color', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Horizontal Align</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'align', this.value)">
                            <option value="left" ${overlay.align === 'left' ? 'selected' : ''}>Left</option>
                            <option value="center" ${overlay.align === 'center' ? 'selected' : ''}>Center</option>
                            <option value="right" ${overlay.align === 'right' ? 'selected' : ''}>Right</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Vertical Position</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'verticalAlign', this.value)">
                            <option value="top" ${overlay.verticalAlign === 'top' ? 'selected' : ''}>Top</option>
                            <option value="middle" ${overlay.verticalAlign === 'middle' ? 'selected' : ''}>Middle</option>
                            <option value="bottom" ${overlay.verticalAlign === 'bottom' ? 'selected' : ''}>Bottom</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Position Offset (X, Y in pixels)</label>
                        <div class="frame-range">
                            <input type="number" value="${overlay.xOffset}" step="1"
                                   onchange="updateTextOverlay(${overlay.id}, 'xOffset', this.value)" placeholder="X offset">
                            <input type="number" value="${overlay.yOffset}" step="1"
                                   onchange="updateTextOverlay(${overlay.id}, 'yOffset', this.value)" placeholder="Y offset">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Text Transform</label>
                        <select onchange="updateTextOverlay(${overlay.id}, 'textTransform', this.value)">
                            <option value="none" ${overlay.textTransform === 'none' ? 'selected' : ''}>None</option>
                            <option value="uppercase" ${overlay.textTransform === 'uppercase' ? 'selected' : ''}>UPPERCASE</option>
                            <option value="lowercase" ${overlay.textTransform === 'lowercase' ? 'selected' : ''}>lowercase</option>
                            <option value="capitalize" ${overlay.textTransform === 'capitalize' ? 'selected' : ''}>Capitalize</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Letter Spacing (px)</label>
                        <input type="number" value="${overlay.letterSpacing}" step="0.5"
                               onchange="updateTextOverlay(${overlay.id}, 'letterSpacing', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Line Height</label>
                        <input type="number" value="${overlay.lineHeight}" step="0.1" min="0.5" max="3"
                               onchange="updateTextOverlay(${overlay.id}, 'lineHeight', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Shadow Blur (px)</label>
                        <input type="number" value="${overlay.shadowBlur}" min="0" max="50"
                               onchange="updateTextOverlay(${overlay.id}, 'shadowBlur', this.value)">
                    </div>

                    <div class="control-group">
                        <label>Shadow Color</label>
                        <input type="color" value="${overlay.shadowColor}" 
                               onchange="updateTextOverlay(${overlay.id}, 'shadowColor', this.value)">
                    </div>
                </div>
            `).join('');
        }

        function toggleLoadMethod() {
            const method = document.getElementById('loadMethod').value;
            const uploadSection = document.getElementById('uploadSection');
            const urlSection = document.getElementById('urlSection');
            
            if (method === 'upload') {
                uploadSection.style.display = 'block';
                urlSection.style.display = 'none';
            } else {
                uploadSection.style.display = 'none';
                urlSection.style.display = 'block';
            }
        }

        async function loadFromURL() {
            const pattern = document.getElementById('urlPattern').value.trim();
            if (!pattern) {
                alert('Please enter a URL pattern');
                return;
            }

            // Parse pattern like: https://example.com/images/frame{001-030}.jpg
            const match = pattern.match(/^(.+)\{(\d+)-(\d+)\}(.+)$/);
            if (!match) {
                alert('Invalid pattern. Use format: https://example.com/images/frame{001-030}.jpg');
                return;
            }

            const [, prefix, startStr, endStr, suffix] = match;
            const start = parseInt(startStr);
            const end = parseInt(endStr);
            const padding = startStr.length;

            if (start > end) {
                alert('Start number must be less than or equal to end number');
                return;
            }

            const urls = [];
            for (let i = start; i <= end; i++) {
                const numStr = String(i).padStart(padding, '0');
                urls.push(prefix + numStr + suffix);
            }

            document.getElementById('fileInfo').textContent = `Loading ${urls.length} images...`;
            
            loadedImages = [];
            let successCount = 0;
            let failCount = 0;

            for (const url of urls) {
                try {
                    const img = new Image();
                    img.crossOrigin = "anonymous"; // Enable CORS if server supports it
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            loadedImages.push(img);
                            successCount++;
                            document.getElementById('fileInfo').textContent = 
                                `Loaded ${successCount}/${urls.length} images${failCount > 0 ? ` (${failCount} failed)` : ''}`;
                            resolve();
                        };
                        img.onerror = () => {
                            failCount++;
                            document.getElementById('fileInfo').textContent = 
                                `Loaded ${successCount}/${urls.length} images${failCount > 0 ? ` (${failCount} failed)` : ''}`;
                            resolve(); // Continue even if one fails
                        };
                        img.src = url;
                    });
                } catch (err) {
                    failCount++;
                }
            }

            if (loadedImages.length === 0) {
                alert('Failed to load any images. Check the URL pattern and ensure CORS is enabled on the server.');
                document.getElementById('fileInfo').textContent = 'No images loaded';
                return;
            }

            document.getElementById('fileInfo').textContent = 
                `${successCount} images loaded successfully${failCount > 0 ? ` (${failCount} failed)` : ''}`;
            
            images = urls.slice(0, successCount);
            updatePreview();
        }

        // Update speed display
        document.getElementById('scrollSpeed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value + 'x';
        });

        // Handle file upload
        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Sort files by name
            files.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

            document.getElementById('fileInfo').textContent = `${files.length} images loaded`;
            
            images = files;
            loadedImages = [];

            // Load all images
            for (const file of files) {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => {
                    img.onload = resolve;
                });
                loadedImages.push(img);
            }

            updatePreview();
        });

        function updatePreview() {
            if (loadedImages.length === 0) return;

            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const wrapper = document.getElementById('previewWrapper');
            const scrollContent = document.getElementById('scrollContent');

            // Get config
            currentConfig.width = parseInt(document.getElementById('widthInput').value) || 800;
            currentConfig.height = parseInt(document.getElementById('heightInput').value) || 600;
            currentConfig.objectFit = document.getElementById('objectFit').value;
            currentConfig.scrollSpeed = parseFloat(document.getElementById('scrollSpeed').value);

            // Set canvas size
            canvas.width = currentConfig.width;
            canvas.height = currentConfig.height;

            // Calculate scroll height based on speed
            const scrollHeight = currentConfig.height + (loadedImages.length * 100 / currentConfig.scrollSpeed);
            scrollContent.style.height = scrollHeight + 'px';

            // Remove scroll indicator
            const indicator = scrollContent.querySelector('.scroll-indicator');
            if (indicator) indicator.style.display = 'none';

            // Render on scroll
            function renderFrame() {
                const scrollTop = wrapper.scrollTop;
                const maxScroll = scrollContent.scrollHeight - wrapper.clientHeight;
                const scrollProgress = Math.min(scrollTop / maxScroll, 1);
                
                const frameIndex = Math.floor(scrollProgress * (loadedImages.length - 1));
                const img = loadedImages[frameIndex];

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawImageWithFit(ctx, img, 0, 0, canvas.width, canvas.height, currentConfig.objectFit);
                
                // Draw text overlays
                textOverlays.forEach(overlay => {
                    if (frameIndex >= overlay.startFrame && frameIndex <= overlay.endFrame) {
                        drawTextOverlay(ctx, overlay, frameIndex, canvas.width, canvas.height);
                    }
                });
            }

            wrapper.removeEventListener('scroll', renderFrame);
            wrapper.addEventListener('scroll', renderFrame);
            
            // Initial render
            renderFrame();

            // Generate embed code
            generateEmbedCode();
        }

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;

            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x;
                    drawY = y;
                    drawWidth = width;
                    drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width;
                    drawHeight = img.height;
                    break;
            }

            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        function drawTextOverlay(ctx, overlay, currentFrame, canvasWidth, canvasHeight) {
            // Calculate opacity based on fade in/out
            let opacity = 1;
            const framesSinceStart = currentFrame - overlay.startFrame;
            const framesUntilEnd = overlay.endFrame - currentFrame;
            
            if (framesSinceStart < overlay.fadeInFrames) {
                opacity = framesSinceStart / overlay.fadeInFrames;
            } else if (framesUntilEnd < overlay.fadeOutFrames) {
                opacity = framesUntilEnd / overlay.fadeOutFrames;
            }
            
            opacity = Math.max(0, Math.min(1, opacity));
            
            // Apply text transform
            let displayText = overlay.text;
            switch(overlay.textTransform) {
                case 'uppercase':
                    displayText = displayText.toUpperCase();
                    break;
                case 'lowercase':
                    displayText = displayText.toLowerCase();
                    break;
                case 'capitalize':
                    displayText = displayText.replace(/\b\w/g, l => l.toUpperCase());
                    break;
            }
            
            // Set font and text properties
            ctx.font = `${overlay.fontSize}px ${overlay.fontFamily}`;
            ctx.globalAlpha = opacity;
            ctx.textAlign = overlay.align;
            
            // Handle letter spacing
            if (overlay.letterSpacing !== 0) {
                ctx.letterSpacing = `${overlay.letterSpacing}px`;
            }
            
            // Split text into lines
            const lines = displayText.split('\n');
            const lineHeight = overlay.fontSize * overlay.lineHeight;
            
            // Calculate vertical position
            let startY;
            const totalHeight = lines.length * lineHeight;
            switch(overlay.verticalAlign) {
                case 'top':
                    startY = overlay.fontSize + 40;
                    break;
                case 'bottom':
                    startY = canvasHeight - totalHeight - 40;
                    break;
                case 'middle':
                default:
                    startY = (canvasHeight - totalHeight) / 2 + overlay.fontSize;
                    break;
            }
            
            // Calculate horizontal position
            let textX;
            switch(overlay.align) {
                case 'left':
                    textX = 40;
                    break;
                case 'right':
                    textX = canvasWidth - 40;
                    break;
                case 'center':
                default:
                    textX = canvasWidth / 2;
                    break;
            }
            
            // Apply offsets
            textX += overlay.xOffset || 0;
            startY += overlay.yOffset || 0;
            
            // Draw each line with shadow
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                
                // Draw shadow if enabled
                if (overlay.shadowBlur > 0) {
                    ctx.shadowColor = overlay.shadowColor;
                    ctx.shadowBlur = overlay.shadowBlur;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                }
                
                // Draw fill text
                ctx.fillStyle = overlay.color;
                ctx.fillText(line, textX, y);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
            
            // Reset properties
            ctx.globalAlpha = 1;
            ctx.letterSpacing = '0px';
        }

        function generateEmbedCode() {
            const loadMethod = document.getElementById('loadMethod').value;
            const urlPattern = document.getElementById('urlPattern').value;
            
            let imagePathsComment = '';
            let imagePathsExample = '';
            
            if (loadMethod === 'url' && urlPattern) {
                imagePathsComment = '// Your URL pattern was: ' + urlPattern;
                imagePathsExample = `                // Generated from pattern
                'path/to/image001.jpg',
                'path/to/image002.jpg',
                'path/to/image003.jpg',`;
            } else {
                imagePathsComment = '// Add your image paths here';
                imagePathsExample = `                'path/to/image001.jpg',
                'path/to/image002.jpg',
                'path/to/image003.jpg',`;
            }

            // Generate custom fonts links
            const customFontsLinks = customFonts.map(font => 
                `    <link rel="stylesheet" href="${font.url}">`
            ).join('\n');

            // Generate text overlays config
            const textOverlaysConfig = textOverlays.length > 0 
                ? ',\n            textOverlays: ' + JSON.stringify(textOverlays.map(t => ({
                    text: t.text,
                    startFrame: t.startFrame,
                    endFrame: t.endFrame,
                    fadeInFrames: t.fadeInFrames,
                    fadeOutFrames: t.fadeOutFrames,
                    fontSize: t.fontSize,
                    fontFamily: t.fontFamily,
                    color: t.color,
                    align: t.align,
                    verticalAlign: t.verticalAlign,
                    textTransform: t.textTransform,
                    letterSpacing: t.letterSpacing,
                    lineHeight: t.lineHeight,
                    xOffset: t.xOffset,
                    yOffset: t.yOffset,
                    shadowBlur: t.shadowBlur,
                    shadowColor: t.shadowColor
                })), null, 12).replace(/\n/g, '\n            ')
                : '';

            const code = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
${customFontsLinks ? customFontsLinks + '\n' : ''}    <style>
        body { margin: 0; padding: 0; }
        .scroll-sequence-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        .scroll-sequence-canvas {
            position: sticky;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div class="scroll-sequence-container" id="sequenceContainer">
        <canvas id="sequenceCanvas" class="scroll-sequence-canvas"></canvas>
    </div>

    <script>
        const config = {
            width: ${currentConfig.width},
            height: ${currentConfig.height},
            objectFit: '${currentConfig.objectFit}',
            scrollSpeed: ${currentConfig.scrollSpeed},
            imagePaths: [
                ${imagePathsComment}
${imagePathsExample}
                // ... more images
            ]${textOverlaysConfig}
        };

        const canvas = document.getElementById('sequenceCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('sequenceContainer');
        
        canvas.width = config.width;
        canvas.height = config.height;

        const images = [];
        let imagesLoaded = 0;

        // Load images
        config.imagePaths.forEach((path, i) => {
            const img = new Image();
            img.src = path;
            img.onload = () => {
                imagesLoaded++;
                if (imagesLoaded === config.imagePaths.length) {
                    render();
                }
            };
            images.push(img);
        });

        // Set container height for scroll
        const scrollHeight = config.height + (images.length * 100 / config.scrollSpeed);
        container.style.height = scrollHeight + 'px';

        function drawImageWithFit(ctx, img, x, y, width, height, fit) {
            const imgRatio = img.width / img.height;
            const canvasRatio = width / height;
            let drawWidth, drawHeight, drawX, drawY;

            switch(fit) {
                case 'cover':
                    if (imgRatio > canvasRatio) {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x - (drawWidth - width) / 2;
                        drawY = y;
                    } else {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y - (drawHeight - height) / 2;
                    }
                    break;
                case 'contain':
                    if (imgRatio > canvasRatio) {
                        drawWidth = width;
                        drawHeight = width / imgRatio;
                        drawX = x;
                        drawY = y + (height - drawHeight) / 2;
                    } else {
                        drawHeight = height;
                        drawWidth = height * imgRatio;
                        drawX = x + (width - drawWidth) / 2;
                        drawY = y;
                    }
                    break;
                case 'fill':
                    drawX = x; drawY = y;
                    drawWidth = width; drawHeight = height;
                    break;
                case 'none':
                    drawX = x + (width - img.width) / 2;
                    drawY = y + (height - img.height) / 2;
                    drawWidth = img.width; drawHeight = img.height;
                    break;
            }
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        }

        function drawTextOverlay(ctx, overlay, currentFrame, canvasWidth, canvasHeight) {
            let opacity = 1;
            const framesSinceStart = currentFrame - overlay.startFrame;
            const framesUntilEnd = overlay.endFrame - currentFrame;
            
            if (framesSinceStart < overlay.fadeInFrames) {
                opacity = framesSinceStart / overlay.fadeInFrames;
            } else if (framesUntilEnd < overlay.fadeOutFrames) {
                opacity = framesUntilEnd / overlay.fadeOutFrames;
            }
            
            opacity = Math.max(0, Math.min(1, opacity));
            
            let displayText = overlay.text;
            switch(overlay.textTransform) {
                case 'uppercase': displayText = displayText.toUpperCase(); break;
                case 'lowercase': displayText = displayText.toLowerCase(); break;
                case 'capitalize': displayText = displayText.replace(/\\b\\w/g, l => l.toUpperCase()); break;
            }
            
            ctx.font = \`\${overlay.fontSize}px \${overlay.fontFamily}\`;
            ctx.globalAlpha = opacity;
            ctx.textAlign = overlay.align;
            
            if (overlay.letterSpacing !== 0) {
                ctx.letterSpacing = \`\${overlay.letterSpacing}px\`;
            }
            
            const lines = displayText.split('\\n');
            const lineHeight = overlay.fontSize * overlay.lineHeight;
            
            let startY;
            const totalHeight = lines.length * lineHeight;
            switch(overlay.verticalAlign) {
                case 'top': startY = overlay.fontSize + 40; break;
                case 'bottom': startY = canvasHeight - totalHeight - 40; break;
                case 'middle':
                default: startY = (canvasHeight - totalHeight) / 2 + overlay.fontSize; break;
            }
            
            let textX;
            switch(overlay.align) {
                case 'left': textX = 40; break;
                case 'right': textX = canvasWidth - 40; break;
                case 'center':
                default: textX = canvasWidth / 2; break;
            }
            
            // Apply offsets
            textX += overlay.xOffset || 0;
            startY += overlay.yOffset || 0;
            
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                
                // Draw shadow if enabled
                if (overlay.shadowBlur > 0) {
                    ctx.shadowColor = overlay.shadowColor;
                    ctx.shadowBlur = overlay.shadowBlur;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                }
                
                // Draw fill text
                ctx.fillStyle = overlay.color;
                ctx.fillText(line, textX, y);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
            
            ctx.globalAlpha = 1;
            ctx.letterSpacing = '0px';
        }

        function render() {
            const scrollTop = window.pageYOffset;
            const maxScroll = container.offsetHeight - window.innerHeight;
            const scrollProgress = Math.min(scrollTop / maxScroll, 1);
            const frameIndex = Math.floor(scrollProgress * (images.length - 1));
            
            const img = images[frameIndex];
            if (img && img.complete) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawImageWithFit(ctx, img, 0, 0, canvas.width, canvas.height, config.objectFit);
                
                // Draw text overlays
                if (config.textOverlays) {
                    config.textOverlays.forEach(overlay => {
                        if (frameIndex >= overlay.startFrame && frameIndex <= overlay.endFrame) {
                            drawTextOverlay(ctx, overlay, frameIndex, canvas.width, canvas.height);
                        }
                    });
                }
            }
        }

        window.addEventListener('scroll', render);
        render();
    <\/script>
</body>
</html>`;

            document.getElementById('embedCode').value = code;
        }

        function copyCode() {
            const textarea = document.getElementById('embedCode');
            textarea.select();
            document.execCommand('copy');
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadInstructions() {
            const code = document.getElementById('embedCode').value;
            
            const instructions = `===========================================
FANTASTIC SCROLLTASTIC - EMBED CODE
===========================================

INSTRUCTIONS:
Sections marked with >>> REPLACE THIS <<< need to be updated with your values.

===========================================

${code}

===========================================
QUICK REFERENCE:
===========================================

1. Replace image paths in the imagePaths array
2. Verify width, height, objectFit, and scrollSpeed settings
3. If you have custom fonts, the <link> tags are already included
4. If you added text overlays, they're in the textOverlays array

Need help? Check the user guide documentation.
`;

            const blob = new Blob([instructions], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fantastic-scrolltastic-instructions.txt';
            link.click();
            window.URL.revokeObjectURL(url);
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Downloaded!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        // Initial code generation
        generateEmbedCode();
        updateCustomFontsList();
        checkCustomAspectRatio();
    </script>
</body>
</html>